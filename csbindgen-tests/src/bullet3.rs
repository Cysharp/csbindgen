/* automatically generated by rust-bindgen 0.64.0 */

pub const SHARED_MEMORY_KEY: u32 = 12347;
pub const SHARED_MEMORY_MAGIC_NUMBER: u32 = 202010061;
pub const MAX_VR_ANALOG_AXIS: u32 = 5;
pub const MAX_VR_BUTTONS: u32 = 64;
pub const MAX_VR_CONTROLLERS: u32 = 8;
pub const MAX_KEYBOARD_EVENTS: u32 = 256;
pub const MAX_MOUSE_EVENTS: u32 = 256;
pub const MAX_SDF_BODIES: u32 = 512;
pub const MAX_USER_DATA_KEY_LENGTH: u32 = 256;
pub const MAX_REQUESTED_BODIES_LENGTH: u32 = 256;
pub const MAX_RAY_INTERSECTION_BATCH_SIZE: u32 = 256;
pub const MAX_RAY_INTERSECTION_BATCH_SIZE_STREAMING: u32 = 16384;
pub const MAX_RAY_HITS: u32 = 256;
pub const VISUAL_SHAPE_MAX_PATH_LEN: u32 = 1024;
pub const B3_MAX_PLUGIN_ARG_SIZE: u32 = 128;
pub const B3_MAX_PLUGIN_ARG_TEXT_LEN: u32 = 1024;
pub const MAX_ISLANDS_ANALYTICS: u32 = 64;
pub const B3_MAX_NUM_VERTICES: u32 = 131072;
pub const B3_MAX_NUM_INDICES: u32 = 524288;
pub const EnumSharedMemoryClientCommand_CMD_INVALID: EnumSharedMemoryClientCommand = 0;
pub const EnumSharedMemoryClientCommand_CMD_LOAD_SDF: EnumSharedMemoryClientCommand = 1;
pub const EnumSharedMemoryClientCommand_CMD_LOAD_URDF: EnumSharedMemoryClientCommand = 2;
pub const EnumSharedMemoryClientCommand_CMD_LOAD_BULLET: EnumSharedMemoryClientCommand = 3;
pub const EnumSharedMemoryClientCommand_CMD_SAVE_BULLET: EnumSharedMemoryClientCommand = 4;
pub const EnumSharedMemoryClientCommand_CMD_LOAD_MJCF: EnumSharedMemoryClientCommand = 5;
pub const EnumSharedMemoryClientCommand_CMD_LOAD_SOFT_BODY: EnumSharedMemoryClientCommand = 6;
pub const EnumSharedMemoryClientCommand_CMD_SEND_BULLET_DATA_STREAM: EnumSharedMemoryClientCommand =
    7;
pub const EnumSharedMemoryClientCommand_CMD_CREATE_BOX_COLLISION_SHAPE:
    EnumSharedMemoryClientCommand = 8;
pub const EnumSharedMemoryClientCommand_CMD_CREATE_RIGID_BODY: EnumSharedMemoryClientCommand = 9;
pub const EnumSharedMemoryClientCommand_CMD_DELETE_RIGID_BODY: EnumSharedMemoryClientCommand = 10;
pub const EnumSharedMemoryClientCommand_CMD_CREATE_SENSOR: EnumSharedMemoryClientCommand = 11;
#[doc = "enable or disable joint feedback for force/torque sensors"]
pub const EnumSharedMemoryClientCommand_CMD_INIT_POSE: EnumSharedMemoryClientCommand = 12;
#[doc = "enable or disable joint feedback for force/torque sensors"]
pub const EnumSharedMemoryClientCommand_CMD_SEND_PHYSICS_SIMULATION_PARAMETERS:
    EnumSharedMemoryClientCommand = 13;
#[doc = "enable or disable joint feedback for force/torque sensors"]
pub const EnumSharedMemoryClientCommand_CMD_SEND_DESIRED_STATE: EnumSharedMemoryClientCommand = 14;
#[doc = "enable or disable joint feedback for force/torque sensors"]
pub const EnumSharedMemoryClientCommand_CMD_REQUEST_ACTUAL_STATE: EnumSharedMemoryClientCommand =
    15;
#[doc = "enable or disable joint feedback for force/torque sensors"]
pub const EnumSharedMemoryClientCommand_CMD_REQUEST_DEBUG_LINES: EnumSharedMemoryClientCommand = 16;
#[doc = "enable or disable joint feedback for force/torque sensors"]
pub const EnumSharedMemoryClientCommand_CMD_REQUEST_BODY_INFO: EnumSharedMemoryClientCommand = 17;
#[doc = "enable or disable joint feedback for force/torque sensors"]
pub const EnumSharedMemoryClientCommand_CMD_REQUEST_INTERNAL_DATA: EnumSharedMemoryClientCommand =
    18;
#[doc = "enable or disable joint feedback for force/torque sensors"]
pub const EnumSharedMemoryClientCommand_CMD_STEP_FORWARD_SIMULATION: EnumSharedMemoryClientCommand =
    19;
#[doc = "enable or disable joint feedback for force/torque sensors"]
pub const EnumSharedMemoryClientCommand_CMD_RESET_SIMULATION: EnumSharedMemoryClientCommand = 20;
#[doc = "enable or disable joint feedback for force/torque sensors"]
pub const EnumSharedMemoryClientCommand_CMD_PICK_BODY: EnumSharedMemoryClientCommand = 21;
#[doc = "enable or disable joint feedback for force/torque sensors"]
pub const EnumSharedMemoryClientCommand_CMD_MOVE_PICKED_BODY: EnumSharedMemoryClientCommand = 22;
#[doc = "enable or disable joint feedback for force/torque sensors"]
pub const EnumSharedMemoryClientCommand_CMD_REMOVE_PICKING_CONSTRAINT_BODY:
    EnumSharedMemoryClientCommand = 23;
#[doc = "enable or disable joint feedback for force/torque sensors"]
pub const EnumSharedMemoryClientCommand_CMD_REQUEST_CAMERA_IMAGE_DATA:
    EnumSharedMemoryClientCommand = 24;
#[doc = "enable or disable joint feedback for force/torque sensors"]
pub const EnumSharedMemoryClientCommand_CMD_APPLY_EXTERNAL_FORCE: EnumSharedMemoryClientCommand =
    25;
#[doc = "enable or disable joint feedback for force/torque sensors"]
pub const EnumSharedMemoryClientCommand_CMD_CALCULATE_INVERSE_DYNAMICS:
    EnumSharedMemoryClientCommand = 26;
#[doc = "enable or disable joint feedback for force/torque sensors"]
pub const EnumSharedMemoryClientCommand_CMD_CALCULATE_INVERSE_KINEMATICS:
    EnumSharedMemoryClientCommand = 27;
#[doc = "enable or disable joint feedback for force/torque sensors"]
pub const EnumSharedMemoryClientCommand_CMD_CALCULATE_JACOBIAN: EnumSharedMemoryClientCommand = 28;
#[doc = "enable or disable joint feedback for force/torque sensors"]
pub const EnumSharedMemoryClientCommand_CMD_CALCULATE_MASS_MATRIX: EnumSharedMemoryClientCommand =
    29;
#[doc = "enable or disable joint feedback for force/torque sensors"]
pub const EnumSharedMemoryClientCommand_CMD_USER_CONSTRAINT: EnumSharedMemoryClientCommand = 30;
#[doc = "enable or disable joint feedback for force/torque sensors"]
pub const EnumSharedMemoryClientCommand_CMD_REQUEST_CONTACT_POINT_INFORMATION:
    EnumSharedMemoryClientCommand = 31;
#[doc = "enable or disable joint feedback for force/torque sensors"]
pub const EnumSharedMemoryClientCommand_CMD_REQUEST_RAY_CAST_INTERSECTIONS:
    EnumSharedMemoryClientCommand = 32;
#[doc = "enable or disable joint feedback for force/torque sensors"]
pub const EnumSharedMemoryClientCommand_CMD_REQUEST_AABB_OVERLAP: EnumSharedMemoryClientCommand =
    33;
#[doc = "enable or disable joint feedback for force/torque sensors"]
pub const EnumSharedMemoryClientCommand_CMD_SAVE_WORLD: EnumSharedMemoryClientCommand = 34;
#[doc = "enable or disable joint feedback for force/torque sensors"]
pub const EnumSharedMemoryClientCommand_CMD_REQUEST_VISUAL_SHAPE_INFO:
    EnumSharedMemoryClientCommand = 35;
#[doc = "enable or disable joint feedback for force/torque sensors"]
pub const EnumSharedMemoryClientCommand_CMD_UPDATE_VISUAL_SHAPE: EnumSharedMemoryClientCommand = 36;
#[doc = "enable or disable joint feedback for force/torque sensors"]
pub const EnumSharedMemoryClientCommand_CMD_LOAD_TEXTURE: EnumSharedMemoryClientCommand = 37;
#[doc = "enable or disable joint feedback for force/torque sensors"]
pub const EnumSharedMemoryClientCommand_CMD_SET_SHADOW: EnumSharedMemoryClientCommand = 38;
#[doc = "enable or disable joint feedback for force/torque sensors"]
pub const EnumSharedMemoryClientCommand_CMD_USER_DEBUG_DRAW: EnumSharedMemoryClientCommand = 39;
#[doc = "enable or disable joint feedback for force/torque sensors"]
pub const EnumSharedMemoryClientCommand_CMD_REQUEST_VR_EVENTS_DATA: EnumSharedMemoryClientCommand =
    40;
#[doc = "enable or disable joint feedback for force/torque sensors"]
pub const EnumSharedMemoryClientCommand_CMD_SET_VR_CAMERA_STATE: EnumSharedMemoryClientCommand = 41;
#[doc = "enable or disable joint feedback for force/torque sensors"]
pub const EnumSharedMemoryClientCommand_CMD_SYNC_BODY_INFO: EnumSharedMemoryClientCommand = 42;
#[doc = "enable or disable joint feedback for force/torque sensors"]
pub const EnumSharedMemoryClientCommand_CMD_STATE_LOGGING: EnumSharedMemoryClientCommand = 43;
#[doc = "enable or disable joint feedback for force/torque sensors"]
pub const EnumSharedMemoryClientCommand_CMD_CONFIGURE_OPENGL_VISUALIZER:
    EnumSharedMemoryClientCommand = 44;
#[doc = "enable or disable joint feedback for force/torque sensors"]
pub const EnumSharedMemoryClientCommand_CMD_REQUEST_KEYBOARD_EVENTS_DATA:
    EnumSharedMemoryClientCommand = 45;
#[doc = "enable or disable joint feedback for force/torque sensors"]
pub const EnumSharedMemoryClientCommand_CMD_REQUEST_OPENGL_VISUALIZER_CAMERA:
    EnumSharedMemoryClientCommand = 46;
#[doc = "enable or disable joint feedback for force/torque sensors"]
pub const EnumSharedMemoryClientCommand_CMD_REMOVE_BODY: EnumSharedMemoryClientCommand = 47;
#[doc = "enable or disable joint feedback for force/torque sensors"]
pub const EnumSharedMemoryClientCommand_CMD_CHANGE_DYNAMICS_INFO: EnumSharedMemoryClientCommand =
    48;
#[doc = "enable or disable joint feedback for force/torque sensors"]
pub const EnumSharedMemoryClientCommand_CMD_GET_DYNAMICS_INFO: EnumSharedMemoryClientCommand = 49;
#[doc = "enable or disable joint feedback for force/torque sensors"]
pub const EnumSharedMemoryClientCommand_CMD_PROFILE_TIMING: EnumSharedMemoryClientCommand = 50;
#[doc = "enable or disable joint feedback for force/torque sensors"]
pub const EnumSharedMemoryClientCommand_CMD_CREATE_COLLISION_SHAPE: EnumSharedMemoryClientCommand =
    51;
#[doc = "enable or disable joint feedback for force/torque sensors"]
pub const EnumSharedMemoryClientCommand_CMD_CREATE_VISUAL_SHAPE: EnumSharedMemoryClientCommand = 52;
#[doc = "enable or disable joint feedback for force/torque sensors"]
pub const EnumSharedMemoryClientCommand_CMD_CREATE_MULTI_BODY: EnumSharedMemoryClientCommand = 53;
#[doc = "enable or disable joint feedback for force/torque sensors"]
pub const EnumSharedMemoryClientCommand_CMD_REQUEST_COLLISION_INFO: EnumSharedMemoryClientCommand =
    54;
#[doc = "enable or disable joint feedback for force/torque sensors"]
pub const EnumSharedMemoryClientCommand_CMD_REQUEST_MOUSE_EVENTS_DATA:
    EnumSharedMemoryClientCommand = 55;
#[doc = "enable or disable joint feedback for force/torque sensors"]
pub const EnumSharedMemoryClientCommand_CMD_CHANGE_TEXTURE: EnumSharedMemoryClientCommand = 56;
#[doc = "enable or disable joint feedback for force/torque sensors"]
pub const EnumSharedMemoryClientCommand_CMD_SET_ADDITIONAL_SEARCH_PATH:
    EnumSharedMemoryClientCommand = 57;
#[doc = "enable or disable joint feedback for force/torque sensors"]
pub const EnumSharedMemoryClientCommand_CMD_CUSTOM_COMMAND: EnumSharedMemoryClientCommand = 58;
#[doc = "enable or disable joint feedback for force/torque sensors"]
pub const EnumSharedMemoryClientCommand_CMD_REQUEST_PHYSICS_SIMULATION_PARAMETERS:
    EnumSharedMemoryClientCommand = 59;
#[doc = "enable or disable joint feedback for force/torque sensors"]
pub const EnumSharedMemoryClientCommand_CMD_SAVE_STATE: EnumSharedMemoryClientCommand = 60;
#[doc = "enable or disable joint feedback for force/torque sensors"]
pub const EnumSharedMemoryClientCommand_CMD_RESTORE_STATE: EnumSharedMemoryClientCommand = 61;
#[doc = "enable or disable joint feedback for force/torque sensors"]
pub const EnumSharedMemoryClientCommand_CMD_REMOVE_STATE: EnumSharedMemoryClientCommand = 62;
#[doc = "enable or disable joint feedback for force/torque sensors"]
pub const EnumSharedMemoryClientCommand_CMD_REQUEST_COLLISION_SHAPE_INFO:
    EnumSharedMemoryClientCommand = 63;
#[doc = "enable or disable joint feedback for force/torque sensors"]
pub const EnumSharedMemoryClientCommand_CMD_SYNC_USER_DATA: EnumSharedMemoryClientCommand = 64;
#[doc = "enable or disable joint feedback for force/torque sensors"]
pub const EnumSharedMemoryClientCommand_CMD_REQUEST_USER_DATA: EnumSharedMemoryClientCommand = 65;
#[doc = "enable or disable joint feedback for force/torque sensors"]
pub const EnumSharedMemoryClientCommand_CMD_ADD_USER_DATA: EnumSharedMemoryClientCommand = 66;
#[doc = "enable or disable joint feedback for force/torque sensors"]
pub const EnumSharedMemoryClientCommand_CMD_REMOVE_USER_DATA: EnumSharedMemoryClientCommand = 67;
#[doc = "enable or disable joint feedback for force/torque sensors"]
pub const EnumSharedMemoryClientCommand_CMD_COLLISION_FILTER: EnumSharedMemoryClientCommand = 68;
#[doc = "enable or disable joint feedback for force/torque sensors"]
pub const EnumSharedMemoryClientCommand_CMD_REQUEST_MESH_DATA: EnumSharedMemoryClientCommand = 69;
#[doc = "enable or disable joint feedback for force/torque sensors"]
pub const EnumSharedMemoryClientCommand_CMD_PERFORM_COLLISION_DETECTION:
    EnumSharedMemoryClientCommand = 70;
#[doc = "enable or disable joint feedback for force/torque sensors"]
pub const EnumSharedMemoryClientCommand_CMD_RESET_MESH_DATA: EnumSharedMemoryClientCommand = 71;
#[doc = "enable or disable joint feedback for force/torque sensors"]
pub const EnumSharedMemoryClientCommand_CMD_REQUEST_TETRA_MESH_DATA: EnumSharedMemoryClientCommand =
    72;
#[doc = "enable or disable joint feedback for force/torque sensors"]
pub const EnumSharedMemoryClientCommand_CMD_MAX_CLIENT_COMMANDS: EnumSharedMemoryClientCommand = 73;
pub type EnumSharedMemoryClientCommand = ::std::os::raw::c_int;
pub const EnumSharedMemoryServerStatus_CMD_SHARED_MEMORY_NOT_INITIALIZED:
    EnumSharedMemoryServerStatus = 0;
pub const EnumSharedMemoryServerStatus_CMD_WAITING_FOR_CLIENT_COMMAND:
    EnumSharedMemoryServerStatus = 1;
pub const EnumSharedMemoryServerStatus_CMD_CLIENT_COMMAND_COMPLETED: EnumSharedMemoryServerStatus =
    2;
pub const EnumSharedMemoryServerStatus_CMD_UNKNOWN_COMMAND_FLUSHED: EnumSharedMemoryServerStatus =
    3;
pub const EnumSharedMemoryServerStatus_CMD_SDF_LOADING_COMPLETED: EnumSharedMemoryServerStatus = 4;
pub const EnumSharedMemoryServerStatus_CMD_SDF_LOADING_FAILED: EnumSharedMemoryServerStatus = 5;
pub const EnumSharedMemoryServerStatus_CMD_URDF_LOADING_COMPLETED: EnumSharedMemoryServerStatus = 6;
pub const EnumSharedMemoryServerStatus_CMD_URDF_LOADING_FAILED: EnumSharedMemoryServerStatus = 7;
pub const EnumSharedMemoryServerStatus_CMD_BULLET_LOADING_COMPLETED: EnumSharedMemoryServerStatus =
    8;
pub const EnumSharedMemoryServerStatus_CMD_BULLET_LOADING_FAILED: EnumSharedMemoryServerStatus = 9;
pub const EnumSharedMemoryServerStatus_CMD_BULLET_SAVING_COMPLETED: EnumSharedMemoryServerStatus =
    10;
pub const EnumSharedMemoryServerStatus_CMD_BULLET_SAVING_FAILED: EnumSharedMemoryServerStatus = 11;
pub const EnumSharedMemoryServerStatus_CMD_MJCF_LOADING_COMPLETED: EnumSharedMemoryServerStatus =
    12;
pub const EnumSharedMemoryServerStatus_CMD_MJCF_LOADING_FAILED: EnumSharedMemoryServerStatus = 13;
pub const EnumSharedMemoryServerStatus_CMD_REQUEST_INTERNAL_DATA_COMPLETED:
    EnumSharedMemoryServerStatus = 14;
pub const EnumSharedMemoryServerStatus_CMD_REQUEST_INTERNAL_DATA_FAILED:
    EnumSharedMemoryServerStatus = 15;
pub const EnumSharedMemoryServerStatus_CMD_BULLET_DATA_STREAM_RECEIVED_COMPLETED:
    EnumSharedMemoryServerStatus = 16;
pub const EnumSharedMemoryServerStatus_CMD_BULLET_DATA_STREAM_RECEIVED_FAILED:
    EnumSharedMemoryServerStatus = 17;
pub const EnumSharedMemoryServerStatus_CMD_BOX_COLLISION_SHAPE_CREATION_COMPLETED:
    EnumSharedMemoryServerStatus = 18;
pub const EnumSharedMemoryServerStatus_CMD_RIGID_BODY_CREATION_COMPLETED:
    EnumSharedMemoryServerStatus = 19;
pub const EnumSharedMemoryServerStatus_CMD_SET_JOINT_FEEDBACK_COMPLETED:
    EnumSharedMemoryServerStatus = 20;
pub const EnumSharedMemoryServerStatus_CMD_ACTUAL_STATE_UPDATE_COMPLETED:
    EnumSharedMemoryServerStatus = 21;
pub const EnumSharedMemoryServerStatus_CMD_ACTUAL_STATE_UPDATE_FAILED:
    EnumSharedMemoryServerStatus = 22;
pub const EnumSharedMemoryServerStatus_CMD_DEBUG_LINES_COMPLETED: EnumSharedMemoryServerStatus = 23;
pub const EnumSharedMemoryServerStatus_CMD_DEBUG_LINES_OVERFLOW_FAILED:
    EnumSharedMemoryServerStatus = 24;
pub const EnumSharedMemoryServerStatus_CMD_DESIRED_STATE_RECEIVED_COMPLETED:
    EnumSharedMemoryServerStatus = 25;
pub const EnumSharedMemoryServerStatus_CMD_STEP_FORWARD_SIMULATION_COMPLETED:
    EnumSharedMemoryServerStatus = 26;
pub const EnumSharedMemoryServerStatus_CMD_RESET_SIMULATION_COMPLETED:
    EnumSharedMemoryServerStatus = 27;
pub const EnumSharedMemoryServerStatus_CMD_CAMERA_IMAGE_COMPLETED: EnumSharedMemoryServerStatus =
    28;
pub const EnumSharedMemoryServerStatus_CMD_CAMERA_IMAGE_FAILED: EnumSharedMemoryServerStatus = 29;
pub const EnumSharedMemoryServerStatus_CMD_BODY_INFO_COMPLETED: EnumSharedMemoryServerStatus = 30;
pub const EnumSharedMemoryServerStatus_CMD_BODY_INFO_FAILED: EnumSharedMemoryServerStatus = 31;
pub const EnumSharedMemoryServerStatus_CMD_INVALID_STATUS: EnumSharedMemoryServerStatus = 32;
pub const EnumSharedMemoryServerStatus_CMD_CALCULATED_INVERSE_DYNAMICS_COMPLETED:
    EnumSharedMemoryServerStatus = 33;
pub const EnumSharedMemoryServerStatus_CMD_CALCULATED_INVERSE_DYNAMICS_FAILED:
    EnumSharedMemoryServerStatus = 34;
pub const EnumSharedMemoryServerStatus_CMD_CALCULATED_JACOBIAN_COMPLETED:
    EnumSharedMemoryServerStatus = 35;
pub const EnumSharedMemoryServerStatus_CMD_CALCULATED_JACOBIAN_FAILED:
    EnumSharedMemoryServerStatus = 36;
pub const EnumSharedMemoryServerStatus_CMD_CALCULATED_MASS_MATRIX_COMPLETED:
    EnumSharedMemoryServerStatus = 37;
pub const EnumSharedMemoryServerStatus_CMD_CALCULATED_MASS_MATRIX_FAILED:
    EnumSharedMemoryServerStatus = 38;
pub const EnumSharedMemoryServerStatus_CMD_CONTACT_POINT_INFORMATION_COMPLETED:
    EnumSharedMemoryServerStatus = 39;
pub const EnumSharedMemoryServerStatus_CMD_CONTACT_POINT_INFORMATION_FAILED:
    EnumSharedMemoryServerStatus = 40;
pub const EnumSharedMemoryServerStatus_CMD_REQUEST_AABB_OVERLAP_COMPLETED:
    EnumSharedMemoryServerStatus = 41;
pub const EnumSharedMemoryServerStatus_CMD_REQUEST_AABB_OVERLAP_FAILED:
    EnumSharedMemoryServerStatus = 42;
pub const EnumSharedMemoryServerStatus_CMD_CALCULATE_INVERSE_KINEMATICS_COMPLETED:
    EnumSharedMemoryServerStatus = 43;
pub const EnumSharedMemoryServerStatus_CMD_CALCULATE_INVERSE_KINEMATICS_FAILED:
    EnumSharedMemoryServerStatus = 44;
pub const EnumSharedMemoryServerStatus_CMD_SAVE_WORLD_COMPLETED: EnumSharedMemoryServerStatus = 45;
pub const EnumSharedMemoryServerStatus_CMD_SAVE_WORLD_FAILED: EnumSharedMemoryServerStatus = 46;
pub const EnumSharedMemoryServerStatus_CMD_VISUAL_SHAPE_INFO_COMPLETED:
    EnumSharedMemoryServerStatus = 47;
pub const EnumSharedMemoryServerStatus_CMD_VISUAL_SHAPE_INFO_FAILED: EnumSharedMemoryServerStatus =
    48;
pub const EnumSharedMemoryServerStatus_CMD_VISUAL_SHAPE_UPDATE_COMPLETED:
    EnumSharedMemoryServerStatus = 49;
pub const EnumSharedMemoryServerStatus_CMD_VISUAL_SHAPE_UPDATE_FAILED:
    EnumSharedMemoryServerStatus = 50;
pub const EnumSharedMemoryServerStatus_CMD_LOAD_TEXTURE_COMPLETED: EnumSharedMemoryServerStatus =
    51;
pub const EnumSharedMemoryServerStatus_CMD_LOAD_TEXTURE_FAILED: EnumSharedMemoryServerStatus = 52;
pub const EnumSharedMemoryServerStatus_CMD_USER_DEBUG_DRAW_COMPLETED: EnumSharedMemoryServerStatus =
    53;
pub const EnumSharedMemoryServerStatus_CMD_USER_DEBUG_DRAW_PARAMETER_COMPLETED:
    EnumSharedMemoryServerStatus = 54;
pub const EnumSharedMemoryServerStatus_CMD_USER_DEBUG_DRAW_FAILED: EnumSharedMemoryServerStatus =
    55;
pub const EnumSharedMemoryServerStatus_CMD_USER_CONSTRAINT_COMPLETED: EnumSharedMemoryServerStatus =
    56;
pub const EnumSharedMemoryServerStatus_CMD_USER_CONSTRAINT_INFO_COMPLETED:
    EnumSharedMemoryServerStatus = 57;
pub const EnumSharedMemoryServerStatus_CMD_USER_CONSTRAINT_REQUEST_STATE_COMPLETED:
    EnumSharedMemoryServerStatus = 58;
pub const EnumSharedMemoryServerStatus_CMD_REMOVE_USER_CONSTRAINT_COMPLETED:
    EnumSharedMemoryServerStatus = 59;
pub const EnumSharedMemoryServerStatus_CMD_CHANGE_USER_CONSTRAINT_COMPLETED:
    EnumSharedMemoryServerStatus = 60;
pub const EnumSharedMemoryServerStatus_CMD_REMOVE_USER_CONSTRAINT_FAILED:
    EnumSharedMemoryServerStatus = 61;
pub const EnumSharedMemoryServerStatus_CMD_CHANGE_USER_CONSTRAINT_FAILED:
    EnumSharedMemoryServerStatus = 62;
pub const EnumSharedMemoryServerStatus_CMD_USER_CONSTRAINT_FAILED: EnumSharedMemoryServerStatus =
    63;
pub const EnumSharedMemoryServerStatus_CMD_REQUEST_VR_EVENTS_DATA_COMPLETED:
    EnumSharedMemoryServerStatus = 64;
pub const EnumSharedMemoryServerStatus_CMD_REQUEST_RAY_CAST_INTERSECTIONS_COMPLETED:
    EnumSharedMemoryServerStatus = 65;
pub const EnumSharedMemoryServerStatus_CMD_SYNC_BODY_INFO_COMPLETED: EnumSharedMemoryServerStatus =
    66;
pub const EnumSharedMemoryServerStatus_CMD_SYNC_BODY_INFO_FAILED: EnumSharedMemoryServerStatus = 67;
pub const EnumSharedMemoryServerStatus_CMD_STATE_LOGGING_COMPLETED: EnumSharedMemoryServerStatus =
    68;
pub const EnumSharedMemoryServerStatus_CMD_STATE_LOGGING_START_COMPLETED:
    EnumSharedMemoryServerStatus = 69;
pub const EnumSharedMemoryServerStatus_CMD_STATE_LOGGING_FAILED: EnumSharedMemoryServerStatus = 70;
pub const EnumSharedMemoryServerStatus_CMD_REQUEST_KEYBOARD_EVENTS_DATA_COMPLETED:
    EnumSharedMemoryServerStatus = 71;
pub const EnumSharedMemoryServerStatus_CMD_REQUEST_KEYBOARD_EVENTS_DATA_FAILED:
    EnumSharedMemoryServerStatus = 72;
pub const EnumSharedMemoryServerStatus_CMD_REQUEST_OPENGL_VISUALIZER_CAMERA_FAILED:
    EnumSharedMemoryServerStatus = 73;
pub const EnumSharedMemoryServerStatus_CMD_REQUEST_OPENGL_VISUALIZER_CAMERA_COMPLETED:
    EnumSharedMemoryServerStatus = 74;
pub const EnumSharedMemoryServerStatus_CMD_REMOVE_BODY_COMPLETED: EnumSharedMemoryServerStatus = 75;
pub const EnumSharedMemoryServerStatus_CMD_REMOVE_BODY_FAILED: EnumSharedMemoryServerStatus = 76;
pub const EnumSharedMemoryServerStatus_CMD_GET_DYNAMICS_INFO_COMPLETED:
    EnumSharedMemoryServerStatus = 77;
pub const EnumSharedMemoryServerStatus_CMD_GET_DYNAMICS_INFO_FAILED: EnumSharedMemoryServerStatus =
    78;
pub const EnumSharedMemoryServerStatus_CMD_CREATE_COLLISION_SHAPE_FAILED:
    EnumSharedMemoryServerStatus = 79;
pub const EnumSharedMemoryServerStatus_CMD_CREATE_COLLISION_SHAPE_COMPLETED:
    EnumSharedMemoryServerStatus = 80;
pub const EnumSharedMemoryServerStatus_CMD_CREATE_VISUAL_SHAPE_FAILED:
    EnumSharedMemoryServerStatus = 81;
pub const EnumSharedMemoryServerStatus_CMD_CREATE_VISUAL_SHAPE_COMPLETED:
    EnumSharedMemoryServerStatus = 82;
pub const EnumSharedMemoryServerStatus_CMD_CREATE_MULTI_BODY_FAILED: EnumSharedMemoryServerStatus =
    83;
pub const EnumSharedMemoryServerStatus_CMD_CREATE_MULTI_BODY_COMPLETED:
    EnumSharedMemoryServerStatus = 84;
pub const EnumSharedMemoryServerStatus_CMD_REQUEST_COLLISION_INFO_COMPLETED:
    EnumSharedMemoryServerStatus = 85;
pub const EnumSharedMemoryServerStatus_CMD_REQUEST_COLLISION_INFO_FAILED:
    EnumSharedMemoryServerStatus = 86;
pub const EnumSharedMemoryServerStatus_CMD_REQUEST_MOUSE_EVENTS_DATA_COMPLETED:
    EnumSharedMemoryServerStatus = 87;
pub const EnumSharedMemoryServerStatus_CMD_CHANGE_TEXTURE_COMMAND_FAILED:
    EnumSharedMemoryServerStatus = 88;
pub const EnumSharedMemoryServerStatus_CMD_CUSTOM_COMMAND_COMPLETED: EnumSharedMemoryServerStatus =
    89;
pub const EnumSharedMemoryServerStatus_CMD_CUSTOM_COMMAND_FAILED: EnumSharedMemoryServerStatus = 90;
pub const EnumSharedMemoryServerStatus_CMD_REQUEST_PHYSICS_SIMULATION_PARAMETERS_COMPLETED:
    EnumSharedMemoryServerStatus = 91;
pub const EnumSharedMemoryServerStatus_CMD_SAVE_STATE_FAILED: EnumSharedMemoryServerStatus = 92;
pub const EnumSharedMemoryServerStatus_CMD_SAVE_STATE_COMPLETED: EnumSharedMemoryServerStatus = 93;
pub const EnumSharedMemoryServerStatus_CMD_RESTORE_STATE_FAILED: EnumSharedMemoryServerStatus = 94;
pub const EnumSharedMemoryServerStatus_CMD_RESTORE_STATE_COMPLETED: EnumSharedMemoryServerStatus =
    95;
pub const EnumSharedMemoryServerStatus_CMD_COLLISION_SHAPE_INFO_COMPLETED:
    EnumSharedMemoryServerStatus = 96;
pub const EnumSharedMemoryServerStatus_CMD_COLLISION_SHAPE_INFO_FAILED:
    EnumSharedMemoryServerStatus = 97;
pub const EnumSharedMemoryServerStatus_CMD_LOAD_SOFT_BODY_FAILED: EnumSharedMemoryServerStatus = 98;
pub const EnumSharedMemoryServerStatus_CMD_LOAD_SOFT_BODY_COMPLETED: EnumSharedMemoryServerStatus =
    99;
pub const EnumSharedMemoryServerStatus_CMD_SYNC_USER_DATA_COMPLETED: EnumSharedMemoryServerStatus =
    100;
pub const EnumSharedMemoryServerStatus_CMD_SYNC_USER_DATA_FAILED: EnumSharedMemoryServerStatus =
    101;
pub const EnumSharedMemoryServerStatus_CMD_REQUEST_USER_DATA_COMPLETED:
    EnumSharedMemoryServerStatus = 102;
pub const EnumSharedMemoryServerStatus_CMD_REQUEST_USER_DATA_FAILED: EnumSharedMemoryServerStatus =
    103;
pub const EnumSharedMemoryServerStatus_CMD_ADD_USER_DATA_COMPLETED: EnumSharedMemoryServerStatus =
    104;
pub const EnumSharedMemoryServerStatus_CMD_ADD_USER_DATA_FAILED: EnumSharedMemoryServerStatus = 105;
pub const EnumSharedMemoryServerStatus_CMD_REMOVE_USER_DATA_COMPLETED:
    EnumSharedMemoryServerStatus = 106;
pub const EnumSharedMemoryServerStatus_CMD_REMOVE_USER_DATA_FAILED: EnumSharedMemoryServerStatus =
    107;
pub const EnumSharedMemoryServerStatus_CMD_REMOVE_STATE_COMPLETED: EnumSharedMemoryServerStatus =
    108;
pub const EnumSharedMemoryServerStatus_CMD_REMOVE_STATE_FAILED: EnumSharedMemoryServerStatus = 109;
pub const EnumSharedMemoryServerStatus_CMD_REQUEST_MESH_DATA_COMPLETED:
    EnumSharedMemoryServerStatus = 110;
pub const EnumSharedMemoryServerStatus_CMD_REQUEST_MESH_DATA_FAILED: EnumSharedMemoryServerStatus =
    111;
pub const EnumSharedMemoryServerStatus_CMD_PERFORM_COLLISION_DETECTION_COMPLETED:
    EnumSharedMemoryServerStatus = 112;
pub const EnumSharedMemoryServerStatus_CMD_RESET_MESH_DATA_COMPLETED: EnumSharedMemoryServerStatus =
    113;
pub const EnumSharedMemoryServerStatus_CMD_RESET_MESH_DATA_FAILED: EnumSharedMemoryServerStatus =
    114;
pub const EnumSharedMemoryServerStatus_CMD_REQUEST_TETRA_MESH_DATA_COMPLETED:
    EnumSharedMemoryServerStatus = 115;
pub const EnumSharedMemoryServerStatus_CMD_REQUEST_TETRA_MESH_DATA_FAILED:
    EnumSharedMemoryServerStatus = 116;
pub const EnumSharedMemoryServerStatus_CMD_MAX_SERVER_COMMANDS: EnumSharedMemoryServerStatus = 117;
pub type EnumSharedMemoryServerStatus = ::std::os::raw::c_int;
pub const JointInfoFlags_JOINT_HAS_MOTORIZED_POWER: JointInfoFlags = 1;
pub type JointInfoFlags = ::std::os::raw::c_int;
pub const COLLISION_SHAPE_TYPE_BOX: _bindgen_ty_1 = 1;
pub const COLLISION_SHAPE_TYPE_CYLINDER_X: _bindgen_ty_1 = 2;
pub const COLLISION_SHAPE_TYPE_CYLINDER_Y: _bindgen_ty_1 = 3;
pub const COLLISION_SHAPE_TYPE_CYLINDER_Z: _bindgen_ty_1 = 4;
pub const COLLISION_SHAPE_TYPE_CAPSULE_X: _bindgen_ty_1 = 5;
pub const COLLISION_SHAPE_TYPE_CAPSULE_Y: _bindgen_ty_1 = 6;
pub const COLLISION_SHAPE_TYPE_CAPSULE_Z: _bindgen_ty_1 = 7;
pub const COLLISION_SHAPE_TYPE_SPHERE: _bindgen_ty_1 = 8;
pub type _bindgen_ty_1 = ::std::os::raw::c_int;
pub const JointType_eRevoluteType: JointType = 0;
pub const JointType_ePrismaticType: JointType = 1;
pub const JointType_eSphericalType: JointType = 2;
pub const JointType_ePlanarType: JointType = 3;
pub const JointType_eFixedType: JointType = 4;
pub const JointType_ePoint2PointType: JointType = 5;
pub const JointType_eGearType: JointType = 6;
pub type JointType = ::std::os::raw::c_int;
pub const b3JointInfoFlags_eJointChangeMaxForce: b3JointInfoFlags = 1;
pub const b3JointInfoFlags_eJointChangeChildFramePosition: b3JointInfoFlags = 2;
pub const b3JointInfoFlags_eJointChangeChildFrameOrientation: b3JointInfoFlags = 4;
pub type b3JointInfoFlags = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3JointInfo {
    pub m_linkName: [::std::os::raw::c_char; 1024usize],
    pub m_jointName: [::std::os::raw::c_char; 1024usize],
    pub m_jointType: ::std::os::raw::c_int,
    pub m_qIndex: ::std::os::raw::c_int,
    pub m_uIndex: ::std::os::raw::c_int,
    pub m_jointIndex: ::std::os::raw::c_int,
    pub m_flags: ::std::os::raw::c_int,
    pub m_jointDamping: f64,
    pub m_jointFriction: f64,
    pub m_jointLowerLimit: f64,
    pub m_jointUpperLimit: f64,
    pub m_jointMaxForce: f64,
    pub m_jointMaxVelocity: f64,
    pub m_parentFrame: [f64; 7usize],
    pub m_childFrame: [f64; 7usize],
    pub m_jointAxis: [f64; 3usize],
    pub m_parentIndex: ::std::os::raw::c_int,
    pub m_qSize: ::std::os::raw::c_int,
    pub m_uSize: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_b3JointInfo() {
    const UNINIT: ::std::mem::MaybeUninit<b3JointInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<b3JointInfo>(),
        2272usize,
        concat!("Size of: ", stringify!(b3JointInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<b3JointInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(b3JointInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_linkName) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(b3JointInfo),
            "::",
            stringify!(m_linkName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_jointName) as usize - ptr as usize },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(b3JointInfo),
            "::",
            stringify!(m_jointName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_jointType) as usize - ptr as usize },
        2048usize,
        concat!(
            "Offset of field: ",
            stringify!(b3JointInfo),
            "::",
            stringify!(m_jointType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_qIndex) as usize - ptr as usize },
        2052usize,
        concat!(
            "Offset of field: ",
            stringify!(b3JointInfo),
            "::",
            stringify!(m_qIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uIndex) as usize - ptr as usize },
        2056usize,
        concat!(
            "Offset of field: ",
            stringify!(b3JointInfo),
            "::",
            stringify!(m_uIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_jointIndex) as usize - ptr as usize },
        2060usize,
        concat!(
            "Offset of field: ",
            stringify!(b3JointInfo),
            "::",
            stringify!(m_jointIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_flags) as usize - ptr as usize },
        2064usize,
        concat!(
            "Offset of field: ",
            stringify!(b3JointInfo),
            "::",
            stringify!(m_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_jointDamping) as usize - ptr as usize },
        2072usize,
        concat!(
            "Offset of field: ",
            stringify!(b3JointInfo),
            "::",
            stringify!(m_jointDamping)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_jointFriction) as usize - ptr as usize },
        2080usize,
        concat!(
            "Offset of field: ",
            stringify!(b3JointInfo),
            "::",
            stringify!(m_jointFriction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_jointLowerLimit) as usize - ptr as usize },
        2088usize,
        concat!(
            "Offset of field: ",
            stringify!(b3JointInfo),
            "::",
            stringify!(m_jointLowerLimit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_jointUpperLimit) as usize - ptr as usize },
        2096usize,
        concat!(
            "Offset of field: ",
            stringify!(b3JointInfo),
            "::",
            stringify!(m_jointUpperLimit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_jointMaxForce) as usize - ptr as usize },
        2104usize,
        concat!(
            "Offset of field: ",
            stringify!(b3JointInfo),
            "::",
            stringify!(m_jointMaxForce)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_jointMaxVelocity) as usize - ptr as usize },
        2112usize,
        concat!(
            "Offset of field: ",
            stringify!(b3JointInfo),
            "::",
            stringify!(m_jointMaxVelocity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_parentFrame) as usize - ptr as usize },
        2120usize,
        concat!(
            "Offset of field: ",
            stringify!(b3JointInfo),
            "::",
            stringify!(m_parentFrame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_childFrame) as usize - ptr as usize },
        2176usize,
        concat!(
            "Offset of field: ",
            stringify!(b3JointInfo),
            "::",
            stringify!(m_childFrame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_jointAxis) as usize - ptr as usize },
        2232usize,
        concat!(
            "Offset of field: ",
            stringify!(b3JointInfo),
            "::",
            stringify!(m_jointAxis)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_parentIndex) as usize - ptr as usize },
        2256usize,
        concat!(
            "Offset of field: ",
            stringify!(b3JointInfo),
            "::",
            stringify!(m_parentIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_qSize) as usize - ptr as usize },
        2260usize,
        concat!(
            "Offset of field: ",
            stringify!(b3JointInfo),
            "::",
            stringify!(m_qSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uSize) as usize - ptr as usize },
        2264usize,
        concat!(
            "Offset of field: ",
            stringify!(b3JointInfo),
            "::",
            stringify!(m_uSize)
        )
    );
}
pub const UserDataValueType_USER_DATA_VALUE_TYPE_BYTES: UserDataValueType = 0;
pub const UserDataValueType_USER_DATA_VALUE_TYPE_STRING: UserDataValueType = 1;
pub type UserDataValueType = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3UserDataValue {
    pub m_type: ::std::os::raw::c_int,
    pub m_length: ::std::os::raw::c_int,
    pub m_data1: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_b3UserDataValue() {
    const UNINIT: ::std::mem::MaybeUninit<b3UserDataValue> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<b3UserDataValue>(),
        16usize,
        concat!("Size of: ", stringify!(b3UserDataValue))
    );
    assert_eq!(
        ::std::mem::align_of::<b3UserDataValue>(),
        8usize,
        concat!("Alignment of ", stringify!(b3UserDataValue))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(b3UserDataValue),
            "::",
            stringify!(m_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(b3UserDataValue),
            "::",
            stringify!(m_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_data1) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(b3UserDataValue),
            "::",
            stringify!(m_data1)
        )
    );
}
pub const EnumUserConstraintFlags_USER_CONSTRAINT_ADD_CONSTRAINT: EnumUserConstraintFlags = 1;
pub const EnumUserConstraintFlags_USER_CONSTRAINT_REMOVE_CONSTRAINT: EnumUserConstraintFlags = 2;
pub const EnumUserConstraintFlags_USER_CONSTRAINT_CHANGE_CONSTRAINT: EnumUserConstraintFlags = 4;
pub const EnumUserConstraintFlags_USER_CONSTRAINT_CHANGE_PIVOT_IN_B: EnumUserConstraintFlags = 8;
pub const EnumUserConstraintFlags_USER_CONSTRAINT_CHANGE_FRAME_ORN_IN_B: EnumUserConstraintFlags =
    16;
pub const EnumUserConstraintFlags_USER_CONSTRAINT_CHANGE_MAX_FORCE: EnumUserConstraintFlags = 32;
pub const EnumUserConstraintFlags_USER_CONSTRAINT_REQUEST_INFO: EnumUserConstraintFlags = 64;
pub const EnumUserConstraintFlags_USER_CONSTRAINT_CHANGE_GEAR_RATIO: EnumUserConstraintFlags = 128;
pub const EnumUserConstraintFlags_USER_CONSTRAINT_CHANGE_GEAR_AUX_LINK: EnumUserConstraintFlags =
    256;
pub const EnumUserConstraintFlags_USER_CONSTRAINT_CHANGE_RELATIVE_POSITION_TARGET:
    EnumUserConstraintFlags = 512;
pub const EnumUserConstraintFlags_USER_CONSTRAINT_CHANGE_ERP: EnumUserConstraintFlags = 1024;
pub const EnumUserConstraintFlags_USER_CONSTRAINT_REQUEST_STATE: EnumUserConstraintFlags = 2048;
pub const EnumUserConstraintFlags_USER_CONSTRAINT_ADD_SOFT_BODY_ANCHOR: EnumUserConstraintFlags =
    4096;
pub type EnumUserConstraintFlags = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3UserConstraint {
    pub m_parentBodyIndex: ::std::os::raw::c_int,
    pub m_parentJointIndex: ::std::os::raw::c_int,
    pub m_childBodyIndex: ::std::os::raw::c_int,
    pub m_childJointIndex: ::std::os::raw::c_int,
    pub m_parentFrame: [f64; 7usize],
    pub m_childFrame: [f64; 7usize],
    pub m_jointAxis: [f64; 3usize],
    pub m_jointType: ::std::os::raw::c_int,
    pub m_maxAppliedForce: f64,
    pub m_userConstraintUniqueId: ::std::os::raw::c_int,
    pub m_gearRatio: f64,
    pub m_gearAuxLink: ::std::os::raw::c_int,
    pub m_relativePositionTarget: f64,
    pub m_erp: f64,
}
#[test]
fn bindgen_test_layout_b3UserConstraint() {
    const UNINIT: ::std::mem::MaybeUninit<b3UserConstraint> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<b3UserConstraint>(),
        208usize,
        concat!("Size of: ", stringify!(b3UserConstraint))
    );
    assert_eq!(
        ::std::mem::align_of::<b3UserConstraint>(),
        8usize,
        concat!("Alignment of ", stringify!(b3UserConstraint))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_parentBodyIndex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(b3UserConstraint),
            "::",
            stringify!(m_parentBodyIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_parentJointIndex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(b3UserConstraint),
            "::",
            stringify!(m_parentJointIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_childBodyIndex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(b3UserConstraint),
            "::",
            stringify!(m_childBodyIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_childJointIndex) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(b3UserConstraint),
            "::",
            stringify!(m_childJointIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_parentFrame) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(b3UserConstraint),
            "::",
            stringify!(m_parentFrame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_childFrame) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(b3UserConstraint),
            "::",
            stringify!(m_childFrame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_jointAxis) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(b3UserConstraint),
            "::",
            stringify!(m_jointAxis)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_jointType) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(b3UserConstraint),
            "::",
            stringify!(m_jointType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_maxAppliedForce) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(b3UserConstraint),
            "::",
            stringify!(m_maxAppliedForce)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_userConstraintUniqueId) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(b3UserConstraint),
            "::",
            stringify!(m_userConstraintUniqueId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_gearRatio) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(b3UserConstraint),
            "::",
            stringify!(m_gearRatio)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_gearAuxLink) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(b3UserConstraint),
            "::",
            stringify!(m_gearAuxLink)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_relativePositionTarget) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(b3UserConstraint),
            "::",
            stringify!(m_relativePositionTarget)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_erp) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(b3UserConstraint),
            "::",
            stringify!(m_erp)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3BodyInfo {
    pub m_baseName: [::std::os::raw::c_char; 1024usize],
    pub m_bodyName: [::std::os::raw::c_char; 1024usize],
}
#[test]
fn bindgen_test_layout_b3BodyInfo() {
    const UNINIT: ::std::mem::MaybeUninit<b3BodyInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<b3BodyInfo>(),
        2048usize,
        concat!("Size of: ", stringify!(b3BodyInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<b3BodyInfo>(),
        1usize,
        concat!("Alignment of ", stringify!(b3BodyInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_baseName) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(b3BodyInfo),
            "::",
            stringify!(m_baseName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bodyName) as usize - ptr as usize },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(b3BodyInfo),
            "::",
            stringify!(m_bodyName)
        )
    );
}
pub const DynamicsActivationState_eActivationStateEnableSleeping: DynamicsActivationState = 1;
pub const DynamicsActivationState_eActivationStateDisableSleeping: DynamicsActivationState = 2;
pub const DynamicsActivationState_eActivationStateWakeUp: DynamicsActivationState = 4;
pub const DynamicsActivationState_eActivationStateSleep: DynamicsActivationState = 8;
pub const DynamicsActivationState_eActivationStateEnableWakeup: DynamicsActivationState = 16;
pub const DynamicsActivationState_eActivationStateDisableWakeup: DynamicsActivationState = 32;
pub type DynamicsActivationState = ::std::os::raw::c_int;
pub const b3BodyType_BT_RIGID_BODY: b3BodyType = 1;
pub const b3BodyType_BT_MULTI_BODY: b3BodyType = 2;
pub const b3BodyType_BT_SOFT_BODY: b3BodyType = 3;
pub type b3BodyType = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3DynamicsInfo {
    pub m_mass: f64,
    pub m_localInertialDiagonal: [f64; 3usize],
    pub m_localInertialFrame: [f64; 7usize],
    pub m_lateralFrictionCoeff: f64,
    pub m_rollingFrictionCoeff: f64,
    pub m_spinningFrictionCoeff: f64,
    pub m_restitution: f64,
    pub m_contactStiffness: f64,
    pub m_contactDamping: f64,
    pub m_activationState: ::std::os::raw::c_int,
    pub m_bodyType: ::std::os::raw::c_int,
    pub m_angularDamping: f64,
    pub m_linearDamping: f64,
    pub m_ccdSweptSphereRadius: f64,
    pub m_contactProcessingThreshold: f64,
    pub m_frictionAnchor: ::std::os::raw::c_int,
    pub m_collisionMargin: f64,
    pub m_dynamicType: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_b3DynamicsInfo() {
    const UNINIT: ::std::mem::MaybeUninit<b3DynamicsInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<b3DynamicsInfo>(),
        200usize,
        concat!("Size of: ", stringify!(b3DynamicsInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<b3DynamicsInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(b3DynamicsInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_mass) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(b3DynamicsInfo),
            "::",
            stringify!(m_mass)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_localInertialDiagonal) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(b3DynamicsInfo),
            "::",
            stringify!(m_localInertialDiagonal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_localInertialFrame) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(b3DynamicsInfo),
            "::",
            stringify!(m_localInertialFrame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_lateralFrictionCoeff) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(b3DynamicsInfo),
            "::",
            stringify!(m_lateralFrictionCoeff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rollingFrictionCoeff) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(b3DynamicsInfo),
            "::",
            stringify!(m_rollingFrictionCoeff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_spinningFrictionCoeff) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(b3DynamicsInfo),
            "::",
            stringify!(m_spinningFrictionCoeff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_restitution) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(b3DynamicsInfo),
            "::",
            stringify!(m_restitution)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_contactStiffness) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(b3DynamicsInfo),
            "::",
            stringify!(m_contactStiffness)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_contactDamping) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(b3DynamicsInfo),
            "::",
            stringify!(m_contactDamping)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_activationState) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(b3DynamicsInfo),
            "::",
            stringify!(m_activationState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bodyType) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(b3DynamicsInfo),
            "::",
            stringify!(m_bodyType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_angularDamping) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(b3DynamicsInfo),
            "::",
            stringify!(m_angularDamping)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_linearDamping) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(b3DynamicsInfo),
            "::",
            stringify!(m_linearDamping)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ccdSweptSphereRadius) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(b3DynamicsInfo),
            "::",
            stringify!(m_ccdSweptSphereRadius)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).m_contactProcessingThreshold) as usize - ptr as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(b3DynamicsInfo),
            "::",
            stringify!(m_contactProcessingThreshold)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_frictionAnchor) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(b3DynamicsInfo),
            "::",
            stringify!(m_frictionAnchor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_collisionMargin) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(b3DynamicsInfo),
            "::",
            stringify!(m_collisionMargin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_dynamicType) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(b3DynamicsInfo),
            "::",
            stringify!(m_dynamicType)
        )
    );
}
pub const SensorType_eSensorForceTorqueType: SensorType = 1;
pub type SensorType = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3JointSensorState {
    pub m_jointPosition: f64,
    pub m_jointVelocity: f64,
    pub m_jointForceTorque: [f64; 6usize],
    pub m_jointMotorTorque: f64,
}
#[test]
fn bindgen_test_layout_b3JointSensorState() {
    const UNINIT: ::std::mem::MaybeUninit<b3JointSensorState> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<b3JointSensorState>(),
        72usize,
        concat!("Size of: ", stringify!(b3JointSensorState))
    );
    assert_eq!(
        ::std::mem::align_of::<b3JointSensorState>(),
        8usize,
        concat!("Alignment of ", stringify!(b3JointSensorState))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_jointPosition) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(b3JointSensorState),
            "::",
            stringify!(m_jointPosition)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_jointVelocity) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(b3JointSensorState),
            "::",
            stringify!(m_jointVelocity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_jointForceTorque) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(b3JointSensorState),
            "::",
            stringify!(m_jointForceTorque)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_jointMotorTorque) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(b3JointSensorState),
            "::",
            stringify!(m_jointMotorTorque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3JointSensorState2 {
    pub m_jointPosition: [f64; 4usize],
    pub m_jointVelocity: [f64; 3usize],
    pub m_jointReactionForceTorque: [f64; 6usize],
    pub m_jointMotorTorqueMultiDof: [f64; 3usize],
    pub m_qDofSize: ::std::os::raw::c_int,
    pub m_uDofSize: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_b3JointSensorState2() {
    const UNINIT: ::std::mem::MaybeUninit<b3JointSensorState2> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<b3JointSensorState2>(),
        136usize,
        concat!("Size of: ", stringify!(b3JointSensorState2))
    );
    assert_eq!(
        ::std::mem::align_of::<b3JointSensorState2>(),
        8usize,
        concat!("Alignment of ", stringify!(b3JointSensorState2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_jointPosition) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(b3JointSensorState2),
            "::",
            stringify!(m_jointPosition)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_jointVelocity) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(b3JointSensorState2),
            "::",
            stringify!(m_jointVelocity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_jointReactionForceTorque) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(b3JointSensorState2),
            "::",
            stringify!(m_jointReactionForceTorque)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_jointMotorTorqueMultiDof) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(b3JointSensorState2),
            "::",
            stringify!(m_jointMotorTorqueMultiDof)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_qDofSize) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(b3JointSensorState2),
            "::",
            stringify!(m_qDofSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uDofSize) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(b3JointSensorState2),
            "::",
            stringify!(m_uDofSize)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3DebugLines {
    pub m_numDebugLines: ::std::os::raw::c_int,
    pub m_linesFrom: *const f32,
    pub m_linesTo: *const f32,
    pub m_linesColor: *const f32,
}
#[test]
fn bindgen_test_layout_b3DebugLines() {
    const UNINIT: ::std::mem::MaybeUninit<b3DebugLines> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<b3DebugLines>(),
        32usize,
        concat!("Size of: ", stringify!(b3DebugLines))
    );
    assert_eq!(
        ::std::mem::align_of::<b3DebugLines>(),
        8usize,
        concat!("Alignment of ", stringify!(b3DebugLines))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_numDebugLines) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(b3DebugLines),
            "::",
            stringify!(m_numDebugLines)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_linesFrom) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(b3DebugLines),
            "::",
            stringify!(m_linesFrom)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_linesTo) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(b3DebugLines),
            "::",
            stringify!(m_linesTo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_linesColor) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(b3DebugLines),
            "::",
            stringify!(m_linesColor)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3OverlappingObject {
    pub m_objectUniqueId: ::std::os::raw::c_int,
    pub m_linkIndex: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_b3OverlappingObject() {
    const UNINIT: ::std::mem::MaybeUninit<b3OverlappingObject> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<b3OverlappingObject>(),
        8usize,
        concat!("Size of: ", stringify!(b3OverlappingObject))
    );
    assert_eq!(
        ::std::mem::align_of::<b3OverlappingObject>(),
        4usize,
        concat!("Alignment of ", stringify!(b3OverlappingObject))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_objectUniqueId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(b3OverlappingObject),
            "::",
            stringify!(m_objectUniqueId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_linkIndex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(b3OverlappingObject),
            "::",
            stringify!(m_linkIndex)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3AABBOverlapData {
    pub m_numOverlappingObjects: ::std::os::raw::c_int,
    pub m_overlappingObjects: *mut b3OverlappingObject,
}
#[test]
fn bindgen_test_layout_b3AABBOverlapData() {
    const UNINIT: ::std::mem::MaybeUninit<b3AABBOverlapData> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<b3AABBOverlapData>(),
        16usize,
        concat!("Size of: ", stringify!(b3AABBOverlapData))
    );
    assert_eq!(
        ::std::mem::align_of::<b3AABBOverlapData>(),
        8usize,
        concat!("Alignment of ", stringify!(b3AABBOverlapData))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_numOverlappingObjects) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(b3AABBOverlapData),
            "::",
            stringify!(m_numOverlappingObjects)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_overlappingObjects) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(b3AABBOverlapData),
            "::",
            stringify!(m_overlappingObjects)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3CameraImageData {
    pub m_pixelWidth: ::std::os::raw::c_int,
    pub m_pixelHeight: ::std::os::raw::c_int,
    pub m_rgbColorData: *const ::std::os::raw::c_uchar,
    pub m_depthValues: *const f32,
    pub m_segmentationMaskValues: *const ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_b3CameraImageData() {
    const UNINIT: ::std::mem::MaybeUninit<b3CameraImageData> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<b3CameraImageData>(),
        32usize,
        concat!("Size of: ", stringify!(b3CameraImageData))
    );
    assert_eq!(
        ::std::mem::align_of::<b3CameraImageData>(),
        8usize,
        concat!("Alignment of ", stringify!(b3CameraImageData))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pixelWidth) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(b3CameraImageData),
            "::",
            stringify!(m_pixelWidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pixelHeight) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(b3CameraImageData),
            "::",
            stringify!(m_pixelHeight)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgbColorData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(b3CameraImageData),
            "::",
            stringify!(m_rgbColorData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_depthValues) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(b3CameraImageData),
            "::",
            stringify!(m_depthValues)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_segmentationMaskValues) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(b3CameraImageData),
            "::",
            stringify!(m_segmentationMaskValues)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3MeshVertex {
    pub x: f64,
    pub y: f64,
    pub z: f64,
    pub w: f64,
}
#[test]
fn bindgen_test_layout_b3MeshVertex() {
    const UNINIT: ::std::mem::MaybeUninit<b3MeshVertex> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<b3MeshVertex>(),
        32usize,
        concat!("Size of: ", stringify!(b3MeshVertex))
    );
    assert_eq!(
        ::std::mem::align_of::<b3MeshVertex>(),
        8usize,
        concat!("Alignment of ", stringify!(b3MeshVertex))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(b3MeshVertex),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(b3MeshVertex),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(b3MeshVertex),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(b3MeshVertex),
            "::",
            stringify!(w)
        )
    );
}
pub const eMeshDataFlags_B3_MESH_DATA_SIMULATION_MESH: eMeshDataFlags = 1;
pub const eMeshDataFlags_B3_MESH_DATA_SIMULATION_INDICES: eMeshDataFlags = 2;
pub const eMeshDataFlags_B3_MESH_DATA_GRAPHICS_INDICES: eMeshDataFlags = 4;
pub const eMeshDataFlags_B3_MESH_DATA_SIMULATION_MESH_VELOCITY: eMeshDataFlags = 8;
pub type eMeshDataFlags = ::std::os::raw::c_int;
pub const eMeshDataEnum_B3_MESH_DATA_COLLISIONSHAPEINDEX: eMeshDataEnum = 1;
pub const eMeshDataEnum_B3_MESH_DATA_FLAGS: eMeshDataEnum = 2;
pub type eMeshDataEnum = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3MeshData {
    pub m_numVertices: ::std::os::raw::c_int,
    pub m_vertices: *mut b3MeshVertex,
}
#[test]
fn bindgen_test_layout_b3MeshData() {
    const UNINIT: ::std::mem::MaybeUninit<b3MeshData> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<b3MeshData>(),
        16usize,
        concat!("Size of: ", stringify!(b3MeshData))
    );
    assert_eq!(
        ::std::mem::align_of::<b3MeshData>(),
        8usize,
        concat!("Alignment of ", stringify!(b3MeshData))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_numVertices) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(b3MeshData),
            "::",
            stringify!(m_numVertices)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_vertices) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(b3MeshData),
            "::",
            stringify!(m_vertices)
        )
    );
}
pub const eTetraMeshDataEnum_B3_TETRA_MESH_DATA_FLAGS: eTetraMeshDataEnum = 2;
pub type eTetraMeshDataEnum = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3TetraMeshData {
    pub m_numVertices: ::std::os::raw::c_int,
    pub m_vertices: *mut b3MeshVertex,
}
#[test]
fn bindgen_test_layout_b3TetraMeshData() {
    const UNINIT: ::std::mem::MaybeUninit<b3TetraMeshData> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<b3TetraMeshData>(),
        16usize,
        concat!("Size of: ", stringify!(b3TetraMeshData))
    );
    assert_eq!(
        ::std::mem::align_of::<b3TetraMeshData>(),
        8usize,
        concat!("Alignment of ", stringify!(b3TetraMeshData))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_numVertices) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(b3TetraMeshData),
            "::",
            stringify!(m_numVertices)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_vertices) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(b3TetraMeshData),
            "::",
            stringify!(m_vertices)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3OpenGLVisualizerCameraInfo {
    pub m_width: ::std::os::raw::c_int,
    pub m_height: ::std::os::raw::c_int,
    pub m_viewMatrix: [f32; 16usize],
    pub m_projectionMatrix: [f32; 16usize],
    pub m_camUp: [f32; 3usize],
    pub m_camForward: [f32; 3usize],
    pub m_horizontal: [f32; 3usize],
    pub m_vertical: [f32; 3usize],
    pub m_yaw: f32,
    pub m_pitch: f32,
    pub m_dist: f32,
    pub m_target: [f32; 3usize],
}
#[test]
fn bindgen_test_layout_b3OpenGLVisualizerCameraInfo() {
    const UNINIT: ::std::mem::MaybeUninit<b3OpenGLVisualizerCameraInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<b3OpenGLVisualizerCameraInfo>(),
        208usize,
        concat!("Size of: ", stringify!(b3OpenGLVisualizerCameraInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<b3OpenGLVisualizerCameraInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(b3OpenGLVisualizerCameraInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(b3OpenGLVisualizerCameraInfo),
            "::",
            stringify!(m_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_height) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(b3OpenGLVisualizerCameraInfo),
            "::",
            stringify!(m_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_viewMatrix) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(b3OpenGLVisualizerCameraInfo),
            "::",
            stringify!(m_viewMatrix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_projectionMatrix) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(b3OpenGLVisualizerCameraInfo),
            "::",
            stringify!(m_projectionMatrix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_camUp) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(b3OpenGLVisualizerCameraInfo),
            "::",
            stringify!(m_camUp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_camForward) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(b3OpenGLVisualizerCameraInfo),
            "::",
            stringify!(m_camForward)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_horizontal) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(b3OpenGLVisualizerCameraInfo),
            "::",
            stringify!(m_horizontal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_vertical) as usize - ptr as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(b3OpenGLVisualizerCameraInfo),
            "::",
            stringify!(m_vertical)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_yaw) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(b3OpenGLVisualizerCameraInfo),
            "::",
            stringify!(m_yaw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pitch) as usize - ptr as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(b3OpenGLVisualizerCameraInfo),
            "::",
            stringify!(m_pitch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_dist) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(b3OpenGLVisualizerCameraInfo),
            "::",
            stringify!(m_dist)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_target) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(b3OpenGLVisualizerCameraInfo),
            "::",
            stringify!(m_target)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3UserConstraintState {
    pub m_appliedConstraintForces: [f64; 6usize],
    pub m_numDofs: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_b3UserConstraintState() {
    const UNINIT: ::std::mem::MaybeUninit<b3UserConstraintState> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<b3UserConstraintState>(),
        56usize,
        concat!("Size of: ", stringify!(b3UserConstraintState))
    );
    assert_eq!(
        ::std::mem::align_of::<b3UserConstraintState>(),
        8usize,
        concat!("Alignment of ", stringify!(b3UserConstraintState))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_appliedConstraintForces) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(b3UserConstraintState),
            "::",
            stringify!(m_appliedConstraintForces)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_numDofs) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(b3UserConstraintState),
            "::",
            stringify!(m_numDofs)
        )
    );
}
pub const b3VREventType_VR_CONTROLLER_MOVE_EVENT: b3VREventType = 1;
pub const b3VREventType_VR_CONTROLLER_BUTTON_EVENT: b3VREventType = 2;
pub const b3VREventType_VR_HMD_MOVE_EVENT: b3VREventType = 4;
pub const b3VREventType_VR_GENERIC_TRACKER_MOVE_EVENT: b3VREventType = 8;
pub type b3VREventType = ::std::os::raw::c_int;
pub const b3VRButtonInfo_eButtonIsDown: b3VRButtonInfo = 1;
pub const b3VRButtonInfo_eButtonTriggered: b3VRButtonInfo = 2;
pub const b3VRButtonInfo_eButtonReleased: b3VRButtonInfo = 4;
pub type b3VRButtonInfo = ::std::os::raw::c_int;
pub const eVRDeviceTypeEnums_VR_DEVICE_CONTROLLER: eVRDeviceTypeEnums = 1;
pub const eVRDeviceTypeEnums_VR_DEVICE_HMD: eVRDeviceTypeEnums = 2;
pub const eVRDeviceTypeEnums_VR_DEVICE_GENERIC_TRACKER: eVRDeviceTypeEnums = 4;
pub type eVRDeviceTypeEnums = ::std::os::raw::c_int;
pub const EVRCameraFlags_VR_CAMERA_TRACK_OBJECT_ORIENTATION: EVRCameraFlags = 1;
pub type EVRCameraFlags = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3VRControllerEvent {
    pub m_controllerId: ::std::os::raw::c_int,
    pub m_deviceType: ::std::os::raw::c_int,
    pub m_numMoveEvents: ::std::os::raw::c_int,
    pub m_numButtonEvents: ::std::os::raw::c_int,
    pub m_pos: [f32; 4usize],
    pub m_orn: [f32; 4usize],
    pub m_analogAxis: f32,
    pub m_auxAnalogAxis: [f32; 10usize],
    pub m_buttons: [::std::os::raw::c_int; 64usize],
}
#[test]
fn bindgen_test_layout_b3VRControllerEvent() {
    const UNINIT: ::std::mem::MaybeUninit<b3VRControllerEvent> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<b3VRControllerEvent>(),
        348usize,
        concat!("Size of: ", stringify!(b3VRControllerEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<b3VRControllerEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(b3VRControllerEvent))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_controllerId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(b3VRControllerEvent),
            "::",
            stringify!(m_controllerId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_deviceType) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(b3VRControllerEvent),
            "::",
            stringify!(m_deviceType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_numMoveEvents) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(b3VRControllerEvent),
            "::",
            stringify!(m_numMoveEvents)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_numButtonEvents) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(b3VRControllerEvent),
            "::",
            stringify!(m_numButtonEvents)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pos) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(b3VRControllerEvent),
            "::",
            stringify!(m_pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_orn) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(b3VRControllerEvent),
            "::",
            stringify!(m_orn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_analogAxis) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(b3VRControllerEvent),
            "::",
            stringify!(m_analogAxis)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_auxAnalogAxis) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(b3VRControllerEvent),
            "::",
            stringify!(m_auxAnalogAxis)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_buttons) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(b3VRControllerEvent),
            "::",
            stringify!(m_buttons)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3VREventsData {
    pub m_numControllerEvents: ::std::os::raw::c_int,
    pub m_controllerEvents: *mut b3VRControllerEvent,
}
#[test]
fn bindgen_test_layout_b3VREventsData() {
    const UNINIT: ::std::mem::MaybeUninit<b3VREventsData> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<b3VREventsData>(),
        16usize,
        concat!("Size of: ", stringify!(b3VREventsData))
    );
    assert_eq!(
        ::std::mem::align_of::<b3VREventsData>(),
        8usize,
        concat!("Alignment of ", stringify!(b3VREventsData))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_numControllerEvents) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(b3VREventsData),
            "::",
            stringify!(m_numControllerEvents)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_controllerEvents) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(b3VREventsData),
            "::",
            stringify!(m_controllerEvents)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3KeyboardEvent {
    pub m_keyCode: ::std::os::raw::c_int,
    pub m_keyState: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_b3KeyboardEvent() {
    const UNINIT: ::std::mem::MaybeUninit<b3KeyboardEvent> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<b3KeyboardEvent>(),
        8usize,
        concat!("Size of: ", stringify!(b3KeyboardEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<b3KeyboardEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(b3KeyboardEvent))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_keyCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(b3KeyboardEvent),
            "::",
            stringify!(m_keyCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_keyState) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(b3KeyboardEvent),
            "::",
            stringify!(m_keyState)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3KeyboardEventsData {
    pub m_numKeyboardEvents: ::std::os::raw::c_int,
    pub m_keyboardEvents: *mut b3KeyboardEvent,
}
#[test]
fn bindgen_test_layout_b3KeyboardEventsData() {
    const UNINIT: ::std::mem::MaybeUninit<b3KeyboardEventsData> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<b3KeyboardEventsData>(),
        16usize,
        concat!("Size of: ", stringify!(b3KeyboardEventsData))
    );
    assert_eq!(
        ::std::mem::align_of::<b3KeyboardEventsData>(),
        8usize,
        concat!("Alignment of ", stringify!(b3KeyboardEventsData))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_numKeyboardEvents) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(b3KeyboardEventsData),
            "::",
            stringify!(m_numKeyboardEvents)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_keyboardEvents) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(b3KeyboardEventsData),
            "::",
            stringify!(m_keyboardEvents)
        )
    );
}
pub const eMouseEventTypeEnums_MOUSE_MOVE_EVENT: eMouseEventTypeEnums = 1;
pub const eMouseEventTypeEnums_MOUSE_BUTTON_EVENT: eMouseEventTypeEnums = 2;
pub type eMouseEventTypeEnums = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3MouseEvent {
    pub m_eventType: ::std::os::raw::c_int,
    pub m_mousePosX: f32,
    pub m_mousePosY: f32,
    pub m_buttonIndex: ::std::os::raw::c_int,
    pub m_buttonState: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_b3MouseEvent() {
    const UNINIT: ::std::mem::MaybeUninit<b3MouseEvent> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<b3MouseEvent>(),
        20usize,
        concat!("Size of: ", stringify!(b3MouseEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<b3MouseEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(b3MouseEvent))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eventType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(b3MouseEvent),
            "::",
            stringify!(m_eventType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_mousePosX) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(b3MouseEvent),
            "::",
            stringify!(m_mousePosX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_mousePosY) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(b3MouseEvent),
            "::",
            stringify!(m_mousePosY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_buttonIndex) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(b3MouseEvent),
            "::",
            stringify!(m_buttonIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_buttonState) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(b3MouseEvent),
            "::",
            stringify!(m_buttonState)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3MouseEventsData {
    pub m_numMouseEvents: ::std::os::raw::c_int,
    pub m_mouseEvents: *mut b3MouseEvent,
}
#[test]
fn bindgen_test_layout_b3MouseEventsData() {
    const UNINIT: ::std::mem::MaybeUninit<b3MouseEventsData> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<b3MouseEventsData>(),
        16usize,
        concat!("Size of: ", stringify!(b3MouseEventsData))
    );
    assert_eq!(
        ::std::mem::align_of::<b3MouseEventsData>(),
        8usize,
        concat!("Alignment of ", stringify!(b3MouseEventsData))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_numMouseEvents) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(b3MouseEventsData),
            "::",
            stringify!(m_numMouseEvents)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_mouseEvents) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(b3MouseEventsData),
            "::",
            stringify!(m_mouseEvents)
        )
    );
}
pub const b3NotificationType_SIMULATION_RESET: b3NotificationType = 0;
pub const b3NotificationType_BODY_ADDED: b3NotificationType = 1;
pub const b3NotificationType_BODY_REMOVED: b3NotificationType = 2;
pub const b3NotificationType_USER_DATA_ADDED: b3NotificationType = 3;
pub const b3NotificationType_USER_DATA_REMOVED: b3NotificationType = 4;
pub const b3NotificationType_LINK_DYNAMICS_CHANGED: b3NotificationType = 5;
pub const b3NotificationType_VISUAL_SHAPE_CHANGED: b3NotificationType = 6;
pub const b3NotificationType_TRANSFORM_CHANGED: b3NotificationType = 7;
pub const b3NotificationType_SIMULATION_STEPPED: b3NotificationType = 8;
pub const b3NotificationType_SOFTBODY_CHANGED: b3NotificationType = 9;
pub type b3NotificationType = ::std::os::raw::c_int;
pub const b3ResetSimulationFlags_RESET_USE_DEFORMABLE_WORLD: b3ResetSimulationFlags = 1;
pub const b3ResetSimulationFlags_RESET_USE_DISCRETE_DYNAMICS_WORLD: b3ResetSimulationFlags = 2;
pub const b3ResetSimulationFlags_RESET_USE_SIMPLE_BROADPHASE: b3ResetSimulationFlags = 4;
pub const b3ResetSimulationFlags_RESET_USE_REDUCED_DEFORMABLE_WORLD: b3ResetSimulationFlags = 8;
pub type b3ResetSimulationFlags = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3BodyNotificationArgs {
    pub m_bodyUniqueId: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_b3BodyNotificationArgs() {
    const UNINIT: ::std::mem::MaybeUninit<b3BodyNotificationArgs> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<b3BodyNotificationArgs>(),
        4usize,
        concat!("Size of: ", stringify!(b3BodyNotificationArgs))
    );
    assert_eq!(
        ::std::mem::align_of::<b3BodyNotificationArgs>(),
        4usize,
        concat!("Alignment of ", stringify!(b3BodyNotificationArgs))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bodyUniqueId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(b3BodyNotificationArgs),
            "::",
            stringify!(m_bodyUniqueId)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3UserDataNotificationArgs {
    pub m_bodyUniqueId: ::std::os::raw::c_int,
    pub m_linkIndex: ::std::os::raw::c_int,
    pub m_visualShapeIndex: ::std::os::raw::c_int,
    pub m_userDataId: ::std::os::raw::c_int,
    pub m_key: [::std::os::raw::c_char; 256usize],
}
#[test]
fn bindgen_test_layout_b3UserDataNotificationArgs() {
    const UNINIT: ::std::mem::MaybeUninit<b3UserDataNotificationArgs> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<b3UserDataNotificationArgs>(),
        272usize,
        concat!("Size of: ", stringify!(b3UserDataNotificationArgs))
    );
    assert_eq!(
        ::std::mem::align_of::<b3UserDataNotificationArgs>(),
        4usize,
        concat!("Alignment of ", stringify!(b3UserDataNotificationArgs))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bodyUniqueId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(b3UserDataNotificationArgs),
            "::",
            stringify!(m_bodyUniqueId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_linkIndex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(b3UserDataNotificationArgs),
            "::",
            stringify!(m_linkIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_visualShapeIndex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(b3UserDataNotificationArgs),
            "::",
            stringify!(m_visualShapeIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_userDataId) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(b3UserDataNotificationArgs),
            "::",
            stringify!(m_userDataId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_key) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(b3UserDataNotificationArgs),
            "::",
            stringify!(m_key)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3LinkNotificationArgs {
    pub m_bodyUniqueId: ::std::os::raw::c_int,
    pub m_linkIndex: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_b3LinkNotificationArgs() {
    const UNINIT: ::std::mem::MaybeUninit<b3LinkNotificationArgs> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<b3LinkNotificationArgs>(),
        8usize,
        concat!("Size of: ", stringify!(b3LinkNotificationArgs))
    );
    assert_eq!(
        ::std::mem::align_of::<b3LinkNotificationArgs>(),
        4usize,
        concat!("Alignment of ", stringify!(b3LinkNotificationArgs))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bodyUniqueId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(b3LinkNotificationArgs),
            "::",
            stringify!(m_bodyUniqueId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_linkIndex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(b3LinkNotificationArgs),
            "::",
            stringify!(m_linkIndex)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3VisualShapeNotificationArgs {
    pub m_bodyUniqueId: ::std::os::raw::c_int,
    pub m_linkIndex: ::std::os::raw::c_int,
    pub m_visualShapeIndex: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_b3VisualShapeNotificationArgs() {
    const UNINIT: ::std::mem::MaybeUninit<b3VisualShapeNotificationArgs> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<b3VisualShapeNotificationArgs>(),
        12usize,
        concat!("Size of: ", stringify!(b3VisualShapeNotificationArgs))
    );
    assert_eq!(
        ::std::mem::align_of::<b3VisualShapeNotificationArgs>(),
        4usize,
        concat!("Alignment of ", stringify!(b3VisualShapeNotificationArgs))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bodyUniqueId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(b3VisualShapeNotificationArgs),
            "::",
            stringify!(m_bodyUniqueId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_linkIndex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(b3VisualShapeNotificationArgs),
            "::",
            stringify!(m_linkIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_visualShapeIndex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(b3VisualShapeNotificationArgs),
            "::",
            stringify!(m_visualShapeIndex)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3TransformChangeNotificationArgs {
    pub m_bodyUniqueId: ::std::os::raw::c_int,
    pub m_linkIndex: ::std::os::raw::c_int,
    pub m_worldPosition: [f64; 3usize],
    pub m_worldRotation: [f64; 4usize],
    pub m_localScaling: [f64; 3usize],
}
#[test]
fn bindgen_test_layout_b3TransformChangeNotificationArgs() {
    const UNINIT: ::std::mem::MaybeUninit<b3TransformChangeNotificationArgs> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<b3TransformChangeNotificationArgs>(),
        88usize,
        concat!("Size of: ", stringify!(b3TransformChangeNotificationArgs))
    );
    assert_eq!(
        ::std::mem::align_of::<b3TransformChangeNotificationArgs>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(b3TransformChangeNotificationArgs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bodyUniqueId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(b3TransformChangeNotificationArgs),
            "::",
            stringify!(m_bodyUniqueId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_linkIndex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(b3TransformChangeNotificationArgs),
            "::",
            stringify!(m_linkIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_worldPosition) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(b3TransformChangeNotificationArgs),
            "::",
            stringify!(m_worldPosition)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_worldRotation) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(b3TransformChangeNotificationArgs),
            "::",
            stringify!(m_worldRotation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_localScaling) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(b3TransformChangeNotificationArgs),
            "::",
            stringify!(m_localScaling)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3SoftBodyChangeNotificationArgs {
    pub m_bodyUniqueId: ::std::os::raw::c_int,
    pub m_linkIndex: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_b3SoftBodyChangeNotificationArgs() {
    const UNINIT: ::std::mem::MaybeUninit<b3SoftBodyChangeNotificationArgs> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<b3SoftBodyChangeNotificationArgs>(),
        8usize,
        concat!("Size of: ", stringify!(b3SoftBodyChangeNotificationArgs))
    );
    assert_eq!(
        ::std::mem::align_of::<b3SoftBodyChangeNotificationArgs>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(b3SoftBodyChangeNotificationArgs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bodyUniqueId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(b3SoftBodyChangeNotificationArgs),
            "::",
            stringify!(m_bodyUniqueId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_linkIndex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(b3SoftBodyChangeNotificationArgs),
            "::",
            stringify!(m_linkIndex)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct b3Notification {
    pub m_notificationType: ::std::os::raw::c_int,
    pub __bindgen_anon_1: b3Notification__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union b3Notification__bindgen_ty_1 {
    pub m_bodyArgs: b3BodyNotificationArgs,
    pub m_userDataArgs: b3UserDataNotificationArgs,
    pub m_linkArgs: b3LinkNotificationArgs,
    pub m_visualShapeArgs: b3VisualShapeNotificationArgs,
    pub m_transformChangeArgs: b3TransformChangeNotificationArgs,
    pub m_softBodyChangeArgs: b3SoftBodyChangeNotificationArgs,
}
#[test]
fn bindgen_test_layout_b3Notification__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<b3Notification__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<b3Notification__bindgen_ty_1>(),
        272usize,
        concat!("Size of: ", stringify!(b3Notification__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<b3Notification__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(b3Notification__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bodyArgs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(b3Notification__bindgen_ty_1),
            "::",
            stringify!(m_bodyArgs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_userDataArgs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(b3Notification__bindgen_ty_1),
            "::",
            stringify!(m_userDataArgs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_linkArgs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(b3Notification__bindgen_ty_1),
            "::",
            stringify!(m_linkArgs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_visualShapeArgs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(b3Notification__bindgen_ty_1),
            "::",
            stringify!(m_visualShapeArgs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_transformChangeArgs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(b3Notification__bindgen_ty_1),
            "::",
            stringify!(m_transformChangeArgs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_softBodyChangeArgs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(b3Notification__bindgen_ty_1),
            "::",
            stringify!(m_softBodyChangeArgs)
        )
    );
}
#[test]
fn bindgen_test_layout_b3Notification() {
    const UNINIT: ::std::mem::MaybeUninit<b3Notification> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<b3Notification>(),
        280usize,
        concat!("Size of: ", stringify!(b3Notification))
    );
    assert_eq!(
        ::std::mem::align_of::<b3Notification>(),
        8usize,
        concat!("Alignment of ", stringify!(b3Notification))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_notificationType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(b3Notification),
            "::",
            stringify!(m_notificationType)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3ContactPointData {
    pub m_contactFlags: ::std::os::raw::c_int,
    pub m_bodyUniqueIdA: ::std::os::raw::c_int,
    pub m_bodyUniqueIdB: ::std::os::raw::c_int,
    pub m_linkIndexA: ::std::os::raw::c_int,
    pub m_linkIndexB: ::std::os::raw::c_int,
    pub m_positionOnAInWS: [f64; 3usize],
    pub m_positionOnBInWS: [f64; 3usize],
    pub m_contactNormalOnBInWS: [f64; 3usize],
    pub m_contactDistance: f64,
    pub m_normalForce: f64,
    pub m_linearFrictionForce1: f64,
    pub m_linearFrictionForce2: f64,
    pub m_linearFrictionDirection1: [f64; 3usize],
    pub m_linearFrictionDirection2: [f64; 3usize],
}
#[test]
fn bindgen_test_layout_b3ContactPointData() {
    const UNINIT: ::std::mem::MaybeUninit<b3ContactPointData> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<b3ContactPointData>(),
        176usize,
        concat!("Size of: ", stringify!(b3ContactPointData))
    );
    assert_eq!(
        ::std::mem::align_of::<b3ContactPointData>(),
        8usize,
        concat!("Alignment of ", stringify!(b3ContactPointData))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_contactFlags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(b3ContactPointData),
            "::",
            stringify!(m_contactFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bodyUniqueIdA) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(b3ContactPointData),
            "::",
            stringify!(m_bodyUniqueIdA)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bodyUniqueIdB) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(b3ContactPointData),
            "::",
            stringify!(m_bodyUniqueIdB)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_linkIndexA) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(b3ContactPointData),
            "::",
            stringify!(m_linkIndexA)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_linkIndexB) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(b3ContactPointData),
            "::",
            stringify!(m_linkIndexB)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_positionOnAInWS) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(b3ContactPointData),
            "::",
            stringify!(m_positionOnAInWS)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_positionOnBInWS) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(b3ContactPointData),
            "::",
            stringify!(m_positionOnBInWS)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_contactNormalOnBInWS) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(b3ContactPointData),
            "::",
            stringify!(m_contactNormalOnBInWS)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_contactDistance) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(b3ContactPointData),
            "::",
            stringify!(m_contactDistance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_normalForce) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(b3ContactPointData),
            "::",
            stringify!(m_normalForce)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_linearFrictionForce1) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(b3ContactPointData),
            "::",
            stringify!(m_linearFrictionForce1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_linearFrictionForce2) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(b3ContactPointData),
            "::",
            stringify!(m_linearFrictionForce2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_linearFrictionDirection1) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(b3ContactPointData),
            "::",
            stringify!(m_linearFrictionDirection1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_linearFrictionDirection2) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(b3ContactPointData),
            "::",
            stringify!(m_linearFrictionDirection2)
        )
    );
}
pub const CONTACT_QUERY_MODE_REPORT_EXISTING_CONTACT_POINTS: _bindgen_ty_2 = 0;
pub const CONTACT_QUERY_MODE_COMPUTE_CLOSEST_POINTS: _bindgen_ty_2 = 1;
pub type _bindgen_ty_2 = ::std::os::raw::c_int;
pub const b3StateLoggingType_STATE_LOGGING_MINITAUR: b3StateLoggingType = 0;
pub const b3StateLoggingType_STATE_LOGGING_GENERIC_ROBOT: b3StateLoggingType = 1;
pub const b3StateLoggingType_STATE_LOGGING_VR_CONTROLLERS: b3StateLoggingType = 2;
pub const b3StateLoggingType_STATE_LOGGING_VIDEO_MP4: b3StateLoggingType = 3;
pub const b3StateLoggingType_STATE_LOGGING_COMMANDS: b3StateLoggingType = 4;
pub const b3StateLoggingType_STATE_LOGGING_CONTACT_POINTS: b3StateLoggingType = 5;
pub const b3StateLoggingType_STATE_LOGGING_PROFILE_TIMINGS: b3StateLoggingType = 6;
pub const b3StateLoggingType_STATE_LOGGING_ALL_COMMANDS: b3StateLoggingType = 7;
pub const b3StateLoggingType_STATE_REPLAY_ALL_COMMANDS: b3StateLoggingType = 8;
pub const b3StateLoggingType_STATE_LOGGING_CUSTOM_TIMER: b3StateLoggingType = 9;
pub type b3StateLoggingType = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3ContactInformation {
    pub m_numContactPoints: ::std::os::raw::c_int,
    pub m_contactPointData: *mut b3ContactPointData,
}
#[test]
fn bindgen_test_layout_b3ContactInformation() {
    const UNINIT: ::std::mem::MaybeUninit<b3ContactInformation> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<b3ContactInformation>(),
        16usize,
        concat!("Size of: ", stringify!(b3ContactInformation))
    );
    assert_eq!(
        ::std::mem::align_of::<b3ContactInformation>(),
        8usize,
        concat!("Alignment of ", stringify!(b3ContactInformation))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_numContactPoints) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(b3ContactInformation),
            "::",
            stringify!(m_numContactPoints)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_contactPointData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(b3ContactInformation),
            "::",
            stringify!(m_contactPointData)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3RayData {
    pub m_rayFromPosition: [f64; 3usize],
    pub m_rayToPosition: [f64; 3usize],
}
#[test]
fn bindgen_test_layout_b3RayData() {
    const UNINIT: ::std::mem::MaybeUninit<b3RayData> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<b3RayData>(),
        48usize,
        concat!("Size of: ", stringify!(b3RayData))
    );
    assert_eq!(
        ::std::mem::align_of::<b3RayData>(),
        8usize,
        concat!("Alignment of ", stringify!(b3RayData))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rayFromPosition) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(b3RayData),
            "::",
            stringify!(m_rayFromPosition)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rayToPosition) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(b3RayData),
            "::",
            stringify!(m_rayToPosition)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3RayHitInfo {
    pub m_hitFraction: f64,
    pub m_hitObjectUniqueId: ::std::os::raw::c_int,
    pub m_hitObjectLinkIndex: ::std::os::raw::c_int,
    pub m_hitPositionWorld: [f64; 3usize],
    pub m_hitNormalWorld: [f64; 3usize],
}
#[test]
fn bindgen_test_layout_b3RayHitInfo() {
    const UNINIT: ::std::mem::MaybeUninit<b3RayHitInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<b3RayHitInfo>(),
        64usize,
        concat!("Size of: ", stringify!(b3RayHitInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<b3RayHitInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(b3RayHitInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hitFraction) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(b3RayHitInfo),
            "::",
            stringify!(m_hitFraction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hitObjectUniqueId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(b3RayHitInfo),
            "::",
            stringify!(m_hitObjectUniqueId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hitObjectLinkIndex) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(b3RayHitInfo),
            "::",
            stringify!(m_hitObjectLinkIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hitPositionWorld) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(b3RayHitInfo),
            "::",
            stringify!(m_hitPositionWorld)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hitNormalWorld) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(b3RayHitInfo),
            "::",
            stringify!(m_hitNormalWorld)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3RaycastInformation {
    pub m_numRayHits: ::std::os::raw::c_int,
    pub m_rayHits: *mut b3RayHitInfo,
}
#[test]
fn bindgen_test_layout_b3RaycastInformation() {
    const UNINIT: ::std::mem::MaybeUninit<b3RaycastInformation> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<b3RaycastInformation>(),
        16usize,
        concat!("Size of: ", stringify!(b3RaycastInformation))
    );
    assert_eq!(
        ::std::mem::align_of::<b3RaycastInformation>(),
        8usize,
        concat!("Alignment of ", stringify!(b3RaycastInformation))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_numRayHits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(b3RaycastInformation),
            "::",
            stringify!(m_numRayHits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rayHits) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(b3RaycastInformation),
            "::",
            stringify!(m_rayHits)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RAY_DATA_UNION {
    pub a: b3RayData,
    pub b: b3RayHitInfo,
}
#[test]
fn bindgen_test_layout_RAY_DATA_UNION() {
    const UNINIT: ::std::mem::MaybeUninit<RAY_DATA_UNION> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RAY_DATA_UNION>(),
        64usize,
        concat!("Size of: ", stringify!(RAY_DATA_UNION))
    );
    assert_eq!(
        ::std::mem::align_of::<RAY_DATA_UNION>(),
        8usize,
        concat!("Alignment of ", stringify!(RAY_DATA_UNION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).a) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RAY_DATA_UNION),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RAY_DATA_UNION),
            "::",
            stringify!(b)
        )
    );
}
pub const b3VisualShapeDataFlags_eVISUAL_SHAPE_DATA_TEXTURE_UNIQUE_IDS: b3VisualShapeDataFlags = 1;
pub type b3VisualShapeDataFlags = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3VisualShapeData {
    pub m_objectUniqueId: ::std::os::raw::c_int,
    pub m_linkIndex: ::std::os::raw::c_int,
    pub m_visualGeometryType: ::std::os::raw::c_int,
    pub m_dimensions: [f64; 3usize],
    pub m_meshAssetFileName: [::std::os::raw::c_char; 1024usize],
    pub m_localVisualFrame: [f64; 7usize],
    pub m_rgbaColor: [f64; 4usize],
    pub m_tinyRendererTextureId: ::std::os::raw::c_int,
    pub m_textureUniqueId: ::std::os::raw::c_int,
    pub m_openglTextureId: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_b3VisualShapeData() {
    const UNINIT: ::std::mem::MaybeUninit<b3VisualShapeData> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<b3VisualShapeData>(),
        1168usize,
        concat!("Size of: ", stringify!(b3VisualShapeData))
    );
    assert_eq!(
        ::std::mem::align_of::<b3VisualShapeData>(),
        8usize,
        concat!("Alignment of ", stringify!(b3VisualShapeData))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_objectUniqueId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(b3VisualShapeData),
            "::",
            stringify!(m_objectUniqueId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_linkIndex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(b3VisualShapeData),
            "::",
            stringify!(m_linkIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_visualGeometryType) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(b3VisualShapeData),
            "::",
            stringify!(m_visualGeometryType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_dimensions) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(b3VisualShapeData),
            "::",
            stringify!(m_dimensions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_meshAssetFileName) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(b3VisualShapeData),
            "::",
            stringify!(m_meshAssetFileName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_localVisualFrame) as usize - ptr as usize },
        1064usize,
        concat!(
            "Offset of field: ",
            stringify!(b3VisualShapeData),
            "::",
            stringify!(m_localVisualFrame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgbaColor) as usize - ptr as usize },
        1120usize,
        concat!(
            "Offset of field: ",
            stringify!(b3VisualShapeData),
            "::",
            stringify!(m_rgbaColor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_tinyRendererTextureId) as usize - ptr as usize },
        1152usize,
        concat!(
            "Offset of field: ",
            stringify!(b3VisualShapeData),
            "::",
            stringify!(m_tinyRendererTextureId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_textureUniqueId) as usize - ptr as usize },
        1156usize,
        concat!(
            "Offset of field: ",
            stringify!(b3VisualShapeData),
            "::",
            stringify!(m_textureUniqueId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_openglTextureId) as usize - ptr as usize },
        1160usize,
        concat!(
            "Offset of field: ",
            stringify!(b3VisualShapeData),
            "::",
            stringify!(m_openglTextureId)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3VisualShapeInformation {
    pub m_numVisualShapes: ::std::os::raw::c_int,
    pub m_visualShapeData: *mut b3VisualShapeData,
}
#[test]
fn bindgen_test_layout_b3VisualShapeInformation() {
    const UNINIT: ::std::mem::MaybeUninit<b3VisualShapeInformation> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<b3VisualShapeInformation>(),
        16usize,
        concat!("Size of: ", stringify!(b3VisualShapeInformation))
    );
    assert_eq!(
        ::std::mem::align_of::<b3VisualShapeInformation>(),
        8usize,
        concat!("Alignment of ", stringify!(b3VisualShapeInformation))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_numVisualShapes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(b3VisualShapeInformation),
            "::",
            stringify!(m_numVisualShapes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_visualShapeData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(b3VisualShapeInformation),
            "::",
            stringify!(m_visualShapeData)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3CollisionShapeData {
    pub m_objectUniqueId: ::std::os::raw::c_int,
    pub m_linkIndex: ::std::os::raw::c_int,
    pub m_collisionGeometryType: ::std::os::raw::c_int,
    pub m_dimensions: [f64; 3usize],
    pub m_localCollisionFrame: [f64; 7usize],
    pub m_meshAssetFileName: [::std::os::raw::c_char; 1024usize],
}
#[test]
fn bindgen_test_layout_b3CollisionShapeData() {
    const UNINIT: ::std::mem::MaybeUninit<b3CollisionShapeData> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<b3CollisionShapeData>(),
        1120usize,
        concat!("Size of: ", stringify!(b3CollisionShapeData))
    );
    assert_eq!(
        ::std::mem::align_of::<b3CollisionShapeData>(),
        8usize,
        concat!("Alignment of ", stringify!(b3CollisionShapeData))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_objectUniqueId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(b3CollisionShapeData),
            "::",
            stringify!(m_objectUniqueId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_linkIndex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(b3CollisionShapeData),
            "::",
            stringify!(m_linkIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_collisionGeometryType) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(b3CollisionShapeData),
            "::",
            stringify!(m_collisionGeometryType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_dimensions) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(b3CollisionShapeData),
            "::",
            stringify!(m_dimensions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_localCollisionFrame) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(b3CollisionShapeData),
            "::",
            stringify!(m_localCollisionFrame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_meshAssetFileName) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(b3CollisionShapeData),
            "::",
            stringify!(m_meshAssetFileName)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3CollisionShapeInformation {
    pub m_numCollisionShapes: ::std::os::raw::c_int,
    pub m_collisionShapeData: *mut b3CollisionShapeData,
}
#[test]
fn bindgen_test_layout_b3CollisionShapeInformation() {
    const UNINIT: ::std::mem::MaybeUninit<b3CollisionShapeInformation> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<b3CollisionShapeInformation>(),
        16usize,
        concat!("Size of: ", stringify!(b3CollisionShapeInformation))
    );
    assert_eq!(
        ::std::mem::align_of::<b3CollisionShapeInformation>(),
        8usize,
        concat!("Alignment of ", stringify!(b3CollisionShapeInformation))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_numCollisionShapes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(b3CollisionShapeInformation),
            "::",
            stringify!(m_numCollisionShapes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_collisionShapeData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(b3CollisionShapeInformation),
            "::",
            stringify!(m_collisionShapeData)
        )
    );
}
pub const eLinkStateFlags_ACTUAL_STATE_COMPUTE_LINKVELOCITY: eLinkStateFlags = 1;
pub const eLinkStateFlags_ACTUAL_STATE_COMPUTE_FORWARD_KINEMATICS: eLinkStateFlags = 2;
pub type eLinkStateFlags = ::std::os::raw::c_int;
#[doc = "b3LinkState provides extra information such as the Cartesian world coordinates\ncenter of mass (COM) of the link, relative to the world reference frame.\nOrientation is a quaternion x,y,z,w\nNote: to compute the URDF link frame (which equals the joint frame at joint position 0)\nuse URDF link frame = link COM frame * inertiaFrame.inverse()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3LinkState {
    pub m_worldPosition: [f64; 3usize],
    pub m_worldOrientation: [f64; 4usize],
    pub m_localInertialPosition: [f64; 3usize],
    pub m_localInertialOrientation: [f64; 4usize],
    #[doc = "world position and orientation of the (URDF) link frame"]
    pub m_worldLinkFramePosition: [f64; 3usize],
    pub m_worldLinkFrameOrientation: [f64; 4usize],
    pub m_worldLinearVelocity: [f64; 3usize],
    pub m_worldAngularVelocity: [f64; 3usize],
    pub m_worldAABBMin: [f64; 3usize],
    pub m_worldAABBMax: [f64; 3usize],
}
#[test]
fn bindgen_test_layout_b3LinkState() {
    const UNINIT: ::std::mem::MaybeUninit<b3LinkState> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<b3LinkState>(),
        264usize,
        concat!("Size of: ", stringify!(b3LinkState))
    );
    assert_eq!(
        ::std::mem::align_of::<b3LinkState>(),
        8usize,
        concat!("Alignment of ", stringify!(b3LinkState))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_worldPosition) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(b3LinkState),
            "::",
            stringify!(m_worldPosition)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_worldOrientation) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(b3LinkState),
            "::",
            stringify!(m_worldOrientation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_localInertialPosition) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(b3LinkState),
            "::",
            stringify!(m_localInertialPosition)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_localInertialOrientation) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(b3LinkState),
            "::",
            stringify!(m_localInertialOrientation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_worldLinkFramePosition) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(b3LinkState),
            "::",
            stringify!(m_worldLinkFramePosition)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_worldLinkFrameOrientation) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(b3LinkState),
            "::",
            stringify!(m_worldLinkFrameOrientation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_worldLinearVelocity) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(b3LinkState),
            "::",
            stringify!(m_worldLinearVelocity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_worldAngularVelocity) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(b3LinkState),
            "::",
            stringify!(m_worldAngularVelocity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_worldAABBMin) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(b3LinkState),
            "::",
            stringify!(m_worldAABBMin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_worldAABBMax) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(b3LinkState),
            "::",
            stringify!(m_worldAABBMax)
        )
    );
}
pub const CONTROL_MODE_VELOCITY: _bindgen_ty_3 = 0;
pub const CONTROL_MODE_TORQUE: _bindgen_ty_3 = 1;
pub const CONTROL_MODE_POSITION_VELOCITY_PD: _bindgen_ty_3 = 2;
pub const CONTROL_MODE_PD: _bindgen_ty_3 = 3;
pub const CONTROL_MODE_STABLE_PD: _bindgen_ty_3 = 4;
pub type _bindgen_ty_3 = ::std::os::raw::c_int;
pub const EnumExternalForceFlags_EF_LINK_FRAME: EnumExternalForceFlags = 1;
pub const EnumExternalForceFlags_EF_WORLD_FRAME: EnumExternalForceFlags = 2;
#[doc = "flags for b3ApplyExternalTorque and b3ApplyExternalForce"]
pub type EnumExternalForceFlags = ::std::os::raw::c_int;
pub const EnumRenderer_ER_TINY_RENDERER: EnumRenderer = 65536;
pub const EnumRenderer_ER_BULLET_HARDWARE_OPENGL: EnumRenderer = 131072;
#[doc = "flags to pick the renderer for synthetic camera"]
pub type EnumRenderer = ::std::os::raw::c_int;
pub const EnumRendererAuxFlags_ER_SEGMENTATION_MASK_OBJECT_AND_LINKINDEX: EnumRendererAuxFlags = 1;
pub const EnumRendererAuxFlags_ER_USE_PROJECTIVE_TEXTURE: EnumRendererAuxFlags = 2;
pub const EnumRendererAuxFlags_ER_NO_SEGMENTATION_MASK: EnumRendererAuxFlags = 4;
pub type EnumRendererAuxFlags = ::std::os::raw::c_int;
pub const EnumCalculateInverseKinematicsFlags_IK_DLS: EnumCalculateInverseKinematicsFlags = 0;
pub const EnumCalculateInverseKinematicsFlags_IK_SDLS: EnumCalculateInverseKinematicsFlags = 1;
pub const EnumCalculateInverseKinematicsFlags_IK_HAS_TARGET_POSITION:
    EnumCalculateInverseKinematicsFlags = 16;
pub const EnumCalculateInverseKinematicsFlags_IK_HAS_TARGET_ORIENTATION:
    EnumCalculateInverseKinematicsFlags = 32;
pub const EnumCalculateInverseKinematicsFlags_IK_HAS_NULL_SPACE_VELOCITY:
    EnumCalculateInverseKinematicsFlags = 64;
pub const EnumCalculateInverseKinematicsFlags_IK_HAS_JOINT_DAMPING:
    EnumCalculateInverseKinematicsFlags = 128;
pub const EnumCalculateInverseKinematicsFlags_IK_HAS_CURRENT_JOINT_POSITIONS:
    EnumCalculateInverseKinematicsFlags = 256;
pub const EnumCalculateInverseKinematicsFlags_IK_HAS_MAX_ITERATIONS:
    EnumCalculateInverseKinematicsFlags = 512;
pub const EnumCalculateInverseKinematicsFlags_IK_HAS_RESIDUAL_THRESHOLD:
    EnumCalculateInverseKinematicsFlags = 1024;
#[doc = "flags to pick the IK solver and other options"]
pub type EnumCalculateInverseKinematicsFlags = ::std::os::raw::c_int;
pub const b3ConfigureDebugVisualizerEnum_COV_ENABLE_GUI: b3ConfigureDebugVisualizerEnum = 1;
pub const b3ConfigureDebugVisualizerEnum_COV_ENABLE_SHADOWS: b3ConfigureDebugVisualizerEnum = 2;
pub const b3ConfigureDebugVisualizerEnum_COV_ENABLE_WIREFRAME: b3ConfigureDebugVisualizerEnum = 3;
pub const b3ConfigureDebugVisualizerEnum_COV_ENABLE_VR_TELEPORTING: b3ConfigureDebugVisualizerEnum =
    4;
pub const b3ConfigureDebugVisualizerEnum_COV_ENABLE_VR_PICKING: b3ConfigureDebugVisualizerEnum = 5;
pub const b3ConfigureDebugVisualizerEnum_COV_ENABLE_VR_RENDER_CONTROLLERS:
    b3ConfigureDebugVisualizerEnum = 6;
pub const b3ConfigureDebugVisualizerEnum_COV_ENABLE_RENDERING: b3ConfigureDebugVisualizerEnum = 7;
pub const b3ConfigureDebugVisualizerEnum_COV_ENABLE_SYNC_RENDERING_INTERNAL:
    b3ConfigureDebugVisualizerEnum = 8;
pub const b3ConfigureDebugVisualizerEnum_COV_ENABLE_KEYBOARD_SHORTCUTS:
    b3ConfigureDebugVisualizerEnum = 9;
pub const b3ConfigureDebugVisualizerEnum_COV_ENABLE_MOUSE_PICKING: b3ConfigureDebugVisualizerEnum =
    10;
pub const b3ConfigureDebugVisualizerEnum_COV_ENABLE_Y_AXIS_UP: b3ConfigureDebugVisualizerEnum = 11;
pub const b3ConfigureDebugVisualizerEnum_COV_ENABLE_TINY_RENDERER: b3ConfigureDebugVisualizerEnum =
    12;
pub const b3ConfigureDebugVisualizerEnum_COV_ENABLE_RGB_BUFFER_PREVIEW:
    b3ConfigureDebugVisualizerEnum = 13;
pub const b3ConfigureDebugVisualizerEnum_COV_ENABLE_DEPTH_BUFFER_PREVIEW:
    b3ConfigureDebugVisualizerEnum = 14;
pub const b3ConfigureDebugVisualizerEnum_COV_ENABLE_SEGMENTATION_MARK_PREVIEW:
    b3ConfigureDebugVisualizerEnum = 15;
pub const b3ConfigureDebugVisualizerEnum_COV_ENABLE_PLANAR_REFLECTION:
    b3ConfigureDebugVisualizerEnum = 16;
pub const b3ConfigureDebugVisualizerEnum_COV_ENABLE_SINGLE_STEP_RENDERING:
    b3ConfigureDebugVisualizerEnum = 17;
pub type b3ConfigureDebugVisualizerEnum = ::std::os::raw::c_int;
pub const b3AddUserDebugItemEnum_DEB_DEBUG_TEXT_ALWAYS_FACE_CAMERA: b3AddUserDebugItemEnum = 1;
pub const b3AddUserDebugItemEnum_DEB_DEBUG_TEXT_USE_TRUE_TYPE_FONTS: b3AddUserDebugItemEnum = 2;
pub const b3AddUserDebugItemEnum_DEB_DEBUG_TEXT_HAS_TRACKING_OBJECT: b3AddUserDebugItemEnum = 4;
pub type b3AddUserDebugItemEnum = ::std::os::raw::c_int;
pub const eCONNECT_METHOD_eCONNECT_GUI: eCONNECT_METHOD = 1;
pub const eCONNECT_METHOD_eCONNECT_DIRECT: eCONNECT_METHOD = 2;
pub const eCONNECT_METHOD_eCONNECT_SHARED_MEMORY: eCONNECT_METHOD = 3;
pub const eCONNECT_METHOD_eCONNECT_UDP: eCONNECT_METHOD = 4;
pub const eCONNECT_METHOD_eCONNECT_TCP: eCONNECT_METHOD = 5;
pub const eCONNECT_METHOD_eCONNECT_EXISTING_EXAMPLE_BROWSER: eCONNECT_METHOD = 6;
pub const eCONNECT_METHOD_eCONNECT_GUI_SERVER: eCONNECT_METHOD = 7;
pub const eCONNECT_METHOD_eCONNECT_GUI_MAIN_THREAD: eCONNECT_METHOD = 8;
pub const eCONNECT_METHOD_eCONNECT_SHARED_MEMORY_SERVER: eCONNECT_METHOD = 9;
pub const eCONNECT_METHOD_eCONNECT_DART: eCONNECT_METHOD = 10;
pub const eCONNECT_METHOD_eCONNECT_MUJOCO: eCONNECT_METHOD = 11;
pub const eCONNECT_METHOD_eCONNECT_GRPC: eCONNECT_METHOD = 12;
pub const eCONNECT_METHOD_eCONNECT_PHYSX: eCONNECT_METHOD = 13;
pub const eCONNECT_METHOD_eCONNECT_SHARED_MEMORY_GUI: eCONNECT_METHOD = 14;
pub const eCONNECT_METHOD_eCONNECT_GRAPHICS_SERVER: eCONNECT_METHOD = 15;
pub const eCONNECT_METHOD_eCONNECT_GRAPHICS_SERVER_TCP: eCONNECT_METHOD = 16;
pub const eCONNECT_METHOD_eCONNECT_GRAPHICS_SERVER_MAIN_THREAD: eCONNECT_METHOD = 17;
pub type eCONNECT_METHOD = ::std::os::raw::c_int;
pub const eURDF_Flags_URDF_USE_INERTIA_FROM_FILE: eURDF_Flags = 2;
pub const eURDF_Flags_URDF_USE_SELF_COLLISION: eURDF_Flags = 8;
pub const eURDF_Flags_URDF_USE_SELF_COLLISION_EXCLUDE_PARENT: eURDF_Flags = 16;
pub const eURDF_Flags_URDF_USE_SELF_COLLISION_EXCLUDE_ALL_PARENTS: eURDF_Flags = 32;
pub const eURDF_Flags_URDF_RESERVED: eURDF_Flags = 64;
pub const eURDF_Flags_URDF_USE_IMPLICIT_CYLINDER: eURDF_Flags = 128;
pub const eURDF_Flags_URDF_GLOBAL_VELOCITIES_MB: eURDF_Flags = 256;
pub const eURDF_Flags_MJCF_COLORS_FROM_FILE: eURDF_Flags = 512;
pub const eURDF_Flags_URDF_ENABLE_CACHED_GRAPHICS_SHAPES: eURDF_Flags = 1024;
pub const eURDF_Flags_URDF_ENABLE_SLEEPING: eURDF_Flags = 2048;
pub const eURDF_Flags_URDF_INITIALIZE_SAT_FEATURES: eURDF_Flags = 4096;
pub const eURDF_Flags_URDF_USE_SELF_COLLISION_INCLUDE_PARENT: eURDF_Flags = 8192;
pub const eURDF_Flags_URDF_PARSE_SENSORS: eURDF_Flags = 16384;
pub const eURDF_Flags_URDF_USE_MATERIAL_COLORS_FROM_MTL: eURDF_Flags = 32768;
pub const eURDF_Flags_URDF_USE_MATERIAL_TRANSPARANCY_FROM_MTL: eURDF_Flags = 65536;
pub const eURDF_Flags_URDF_MAINTAIN_LINK_ORDER: eURDF_Flags = 131072;
pub const eURDF_Flags_URDF_ENABLE_WAKEUP: eURDF_Flags = 262144;
pub const eURDF_Flags_URDF_MERGE_FIXED_LINKS: eURDF_Flags = 524288;
pub const eURDF_Flags_URDF_IGNORE_VISUAL_SHAPES: eURDF_Flags = 1048576;
pub const eURDF_Flags_URDF_IGNORE_COLLISION_SHAPES: eURDF_Flags = 2097152;
pub const eURDF_Flags_URDF_PRINT_URDF_INFO: eURDF_Flags = 4194304;
pub const eURDF_Flags_URDF_GOOGLEY_UNDEFINED_COLORS: eURDF_Flags = 8388608;
pub type eURDF_Flags = ::std::os::raw::c_int;
pub const eUrdfGeomTypes_GEOM_SPHERE: eUrdfGeomTypes = 2;
pub const eUrdfGeomTypes_GEOM_BOX: eUrdfGeomTypes = 3;
pub const eUrdfGeomTypes_GEOM_CYLINDER: eUrdfGeomTypes = 4;
pub const eUrdfGeomTypes_GEOM_MESH: eUrdfGeomTypes = 5;
pub const eUrdfGeomTypes_GEOM_PLANE: eUrdfGeomTypes = 6;
pub const eUrdfGeomTypes_GEOM_CAPSULE: eUrdfGeomTypes = 7;
pub const eUrdfGeomTypes_GEOM_SDF: eUrdfGeomTypes = 8;
pub const eUrdfGeomTypes_GEOM_HEIGHTFIELD: eUrdfGeomTypes = 9;
pub const eUrdfGeomTypes_GEOM_UNKNOWN: eUrdfGeomTypes = 10;
pub type eUrdfGeomTypes = ::std::os::raw::c_int;
pub const eUrdfCollisionFlags_GEOM_FORCE_CONCAVE_TRIMESH: eUrdfCollisionFlags = 1;
pub const eUrdfCollisionFlags_GEOM_CONCAVE_INTERNAL_EDGE: eUrdfCollisionFlags = 2;
pub const eUrdfCollisionFlags_GEOM_INITIALIZE_SAT_FEATURES: eUrdfCollisionFlags = 4096;
pub type eUrdfCollisionFlags = ::std::os::raw::c_int;
pub const eUrdfVisualFlags_GEOM_VISUAL_HAS_RGBA_COLOR: eUrdfVisualFlags = 1;
pub const eUrdfVisualFlags_GEOM_VISUAL_HAS_SPECULAR_COLOR: eUrdfVisualFlags = 2;
pub type eUrdfVisualFlags = ::std::os::raw::c_int;
pub const eStateLoggingFlags_STATE_LOG_JOINT_MOTOR_TORQUES: eStateLoggingFlags = 1;
pub const eStateLoggingFlags_STATE_LOG_JOINT_USER_TORQUES: eStateLoggingFlags = 2;
pub const eStateLoggingFlags_STATE_LOG_JOINT_TORQUES: eStateLoggingFlags = 3;
pub type eStateLoggingFlags = ::std::os::raw::c_int;
pub const eJointFeedbackModes_JOINT_FEEDBACK_IN_WORLD_SPACE: eJointFeedbackModes = 1;
pub const eJointFeedbackModes_JOINT_FEEDBACK_IN_JOINT_FRAME: eJointFeedbackModes = 2;
pub type eJointFeedbackModes = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3PluginArguments {
    pub m_text: [::std::os::raw::c_char; 1024usize],
    pub m_numInts: ::std::os::raw::c_int,
    pub m_ints: [::std::os::raw::c_int; 128usize],
    pub m_numFloats: ::std::os::raw::c_int,
    pub m_floats: [f64; 128usize],
}
#[test]
fn bindgen_test_layout_b3PluginArguments() {
    const UNINIT: ::std::mem::MaybeUninit<b3PluginArguments> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<b3PluginArguments>(),
        2568usize,
        concat!("Size of: ", stringify!(b3PluginArguments))
    );
    assert_eq!(
        ::std::mem::align_of::<b3PluginArguments>(),
        8usize,
        concat!("Alignment of ", stringify!(b3PluginArguments))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_text) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(b3PluginArguments),
            "::",
            stringify!(m_text)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_numInts) as usize - ptr as usize },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(b3PluginArguments),
            "::",
            stringify!(m_numInts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ints) as usize - ptr as usize },
        1028usize,
        concat!(
            "Offset of field: ",
            stringify!(b3PluginArguments),
            "::",
            stringify!(m_ints)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_numFloats) as usize - ptr as usize },
        1540usize,
        concat!(
            "Offset of field: ",
            stringify!(b3PluginArguments),
            "::",
            stringify!(m_numFloats)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_floats) as usize - ptr as usize },
        1544usize,
        concat!(
            "Offset of field: ",
            stringify!(b3PluginArguments),
            "::",
            stringify!(m_floats)
        )
    );
}
pub const eInternalSimFlags_eVRTinyGUI: eInternalSimFlags = 2;
pub const eInternalSimFlags_eDeformableAlternativeIndexing: eInternalSimFlags = 4;
pub type eInternalSimFlags = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3PhysicsSimulationParameters {
    pub m_deltaTime: f64,
    pub m_simulationTimestamp: f64,
    pub m_gravityAcceleration: [f64; 3usize],
    pub m_numSimulationSubSteps: ::std::os::raw::c_int,
    pub m_numSolverIterations: ::std::os::raw::c_int,
    pub m_warmStartingFactor: f64,
    pub m_articulatedWarmStartingFactor: f64,
    pub m_useRealTimeSimulation: ::std::os::raw::c_int,
    pub m_useSplitImpulse: ::std::os::raw::c_int,
    pub m_splitImpulsePenetrationThreshold: f64,
    pub m_contactBreakingThreshold: f64,
    pub m_internalSimFlags: ::std::os::raw::c_int,
    pub m_defaultContactERP: f64,
    pub m_collisionFilterMode: ::std::os::raw::c_int,
    pub m_enableFileCaching: ::std::os::raw::c_int,
    pub m_restitutionVelocityThreshold: f64,
    pub m_defaultNonContactERP: f64,
    pub m_frictionERP: f64,
    pub m_defaultGlobalCFM: f64,
    pub m_frictionCFM: f64,
    pub m_enableConeFriction: ::std::os::raw::c_int,
    pub m_deterministicOverlappingPairs: ::std::os::raw::c_int,
    pub m_allowedCcdPenetration: f64,
    pub m_jointFeedbackMode: ::std::os::raw::c_int,
    pub m_solverResidualThreshold: f64,
    pub m_contactSlop: f64,
    pub m_enableSAT: ::std::os::raw::c_int,
    pub m_constraintSolverType: ::std::os::raw::c_int,
    pub m_minimumSolverIslandSize: ::std::os::raw::c_int,
    pub m_reportSolverAnalytics: ::std::os::raw::c_int,
    pub m_sparseSdfVoxelSize: f64,
    pub m_numNonContactInnerIterations: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_b3PhysicsSimulationParameters() {
    const UNINIT: ::std::mem::MaybeUninit<b3PhysicsSimulationParameters> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<b3PhysicsSimulationParameters>(),
        224usize,
        concat!("Size of: ", stringify!(b3PhysicsSimulationParameters))
    );
    assert_eq!(
        ::std::mem::align_of::<b3PhysicsSimulationParameters>(),
        8usize,
        concat!("Alignment of ", stringify!(b3PhysicsSimulationParameters))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_deltaTime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(b3PhysicsSimulationParameters),
            "::",
            stringify!(m_deltaTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_simulationTimestamp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(b3PhysicsSimulationParameters),
            "::",
            stringify!(m_simulationTimestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_gravityAcceleration) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(b3PhysicsSimulationParameters),
            "::",
            stringify!(m_gravityAcceleration)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_numSimulationSubSteps) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(b3PhysicsSimulationParameters),
            "::",
            stringify!(m_numSimulationSubSteps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_numSolverIterations) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(b3PhysicsSimulationParameters),
            "::",
            stringify!(m_numSolverIterations)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_warmStartingFactor) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(b3PhysicsSimulationParameters),
            "::",
            stringify!(m_warmStartingFactor)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).m_articulatedWarmStartingFactor) as usize - ptr as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(b3PhysicsSimulationParameters),
            "::",
            stringify!(m_articulatedWarmStartingFactor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_useRealTimeSimulation) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(b3PhysicsSimulationParameters),
            "::",
            stringify!(m_useRealTimeSimulation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_useSplitImpulse) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(b3PhysicsSimulationParameters),
            "::",
            stringify!(m_useSplitImpulse)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).m_splitImpulsePenetrationThreshold) as usize - ptr as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(b3PhysicsSimulationParameters),
            "::",
            stringify!(m_splitImpulsePenetrationThreshold)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_contactBreakingThreshold) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(b3PhysicsSimulationParameters),
            "::",
            stringify!(m_contactBreakingThreshold)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_internalSimFlags) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(b3PhysicsSimulationParameters),
            "::",
            stringify!(m_internalSimFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_defaultContactERP) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(b3PhysicsSimulationParameters),
            "::",
            stringify!(m_defaultContactERP)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_collisionFilterMode) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(b3PhysicsSimulationParameters),
            "::",
            stringify!(m_collisionFilterMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_enableFileCaching) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(b3PhysicsSimulationParameters),
            "::",
            stringify!(m_enableFileCaching)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).m_restitutionVelocityThreshold) as usize - ptr as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(b3PhysicsSimulationParameters),
            "::",
            stringify!(m_restitutionVelocityThreshold)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_defaultNonContactERP) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(b3PhysicsSimulationParameters),
            "::",
            stringify!(m_defaultNonContactERP)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_frictionERP) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(b3PhysicsSimulationParameters),
            "::",
            stringify!(m_frictionERP)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_defaultGlobalCFM) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(b3PhysicsSimulationParameters),
            "::",
            stringify!(m_defaultGlobalCFM)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_frictionCFM) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(b3PhysicsSimulationParameters),
            "::",
            stringify!(m_frictionCFM)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_enableConeFriction) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(b3PhysicsSimulationParameters),
            "::",
            stringify!(m_enableConeFriction)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).m_deterministicOverlappingPairs) as usize - ptr as usize
        },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(b3PhysicsSimulationParameters),
            "::",
            stringify!(m_deterministicOverlappingPairs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_allowedCcdPenetration) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(b3PhysicsSimulationParameters),
            "::",
            stringify!(m_allowedCcdPenetration)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_jointFeedbackMode) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(b3PhysicsSimulationParameters),
            "::",
            stringify!(m_jointFeedbackMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_solverResidualThreshold) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(b3PhysicsSimulationParameters),
            "::",
            stringify!(m_solverResidualThreshold)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_contactSlop) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(b3PhysicsSimulationParameters),
            "::",
            stringify!(m_contactSlop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_enableSAT) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(b3PhysicsSimulationParameters),
            "::",
            stringify!(m_enableSAT)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_constraintSolverType) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(b3PhysicsSimulationParameters),
            "::",
            stringify!(m_constraintSolverType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_minimumSolverIslandSize) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(b3PhysicsSimulationParameters),
            "::",
            stringify!(m_minimumSolverIslandSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_reportSolverAnalytics) as usize - ptr as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(b3PhysicsSimulationParameters),
            "::",
            stringify!(m_reportSolverAnalytics)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_sparseSdfVoxelSize) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(b3PhysicsSimulationParameters),
            "::",
            stringify!(m_sparseSdfVoxelSize)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).m_numNonContactInnerIterations) as usize - ptr as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(b3PhysicsSimulationParameters),
            "::",
            stringify!(m_numNonContactInnerIterations)
        )
    );
}
pub const eConstraintSolverTypes_eConstraintSolverLCP_SI: eConstraintSolverTypes = 1;
pub const eConstraintSolverTypes_eConstraintSolverLCP_PGS: eConstraintSolverTypes = 2;
pub const eConstraintSolverTypes_eConstraintSolverLCP_DANTZIG: eConstraintSolverTypes = 3;
pub const eConstraintSolverTypes_eConstraintSolverLCP_LEMKE: eConstraintSolverTypes = 4;
pub const eConstraintSolverTypes_eConstraintSolverLCP_NNCG: eConstraintSolverTypes = 5;
pub const eConstraintSolverTypes_eConstraintSolverLCP_BLOCK_PGS: eConstraintSolverTypes = 6;
pub type eConstraintSolverTypes = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3ForwardDynamicsAnalyticsIslandData {
    pub m_islandId: ::std::os::raw::c_int,
    pub m_numBodies: ::std::os::raw::c_int,
    pub m_numContactManifolds: ::std::os::raw::c_int,
    pub m_numIterationsUsed: ::std::os::raw::c_int,
    pub m_remainingLeastSquaresResidual: f64,
}
#[test]
fn bindgen_test_layout_b3ForwardDynamicsAnalyticsIslandData() {
    const UNINIT: ::std::mem::MaybeUninit<b3ForwardDynamicsAnalyticsIslandData> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<b3ForwardDynamicsAnalyticsIslandData>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(b3ForwardDynamicsAnalyticsIslandData)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<b3ForwardDynamicsAnalyticsIslandData>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(b3ForwardDynamicsAnalyticsIslandData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_islandId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(b3ForwardDynamicsAnalyticsIslandData),
            "::",
            stringify!(m_islandId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_numBodies) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(b3ForwardDynamicsAnalyticsIslandData),
            "::",
            stringify!(m_numBodies)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_numContactManifolds) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(b3ForwardDynamicsAnalyticsIslandData),
            "::",
            stringify!(m_numContactManifolds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_numIterationsUsed) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(b3ForwardDynamicsAnalyticsIslandData),
            "::",
            stringify!(m_numIterationsUsed)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).m_remainingLeastSquaresResidual) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(b3ForwardDynamicsAnalyticsIslandData),
            "::",
            stringify!(m_remainingLeastSquaresResidual)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3ForwardDynamicsAnalyticsArgs {
    pub m_numSteps: ::std::os::raw::c_int,
    pub m_numIslands: ::std::os::raw::c_int,
    pub m_numSolverCalls: ::std::os::raw::c_int,
    pub m_islandData: [b3ForwardDynamicsAnalyticsIslandData; 64usize],
}
#[test]
fn bindgen_test_layout_b3ForwardDynamicsAnalyticsArgs() {
    const UNINIT: ::std::mem::MaybeUninit<b3ForwardDynamicsAnalyticsArgs> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<b3ForwardDynamicsAnalyticsArgs>(),
        1552usize,
        concat!("Size of: ", stringify!(b3ForwardDynamicsAnalyticsArgs))
    );
    assert_eq!(
        ::std::mem::align_of::<b3ForwardDynamicsAnalyticsArgs>(),
        8usize,
        concat!("Alignment of ", stringify!(b3ForwardDynamicsAnalyticsArgs))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_numSteps) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(b3ForwardDynamicsAnalyticsArgs),
            "::",
            stringify!(m_numSteps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_numIslands) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(b3ForwardDynamicsAnalyticsArgs),
            "::",
            stringify!(m_numIslands)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_numSolverCalls) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(b3ForwardDynamicsAnalyticsArgs),
            "::",
            stringify!(m_numSolverCalls)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_islandData) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(b3ForwardDynamicsAnalyticsArgs),
            "::",
            stringify!(m_islandData)
        )
    );
}
pub const eDynamicTypes_eDynamic: eDynamicTypes = 0;
pub const eDynamicTypes_eStatic: eDynamicTypes = 1;
pub const eDynamicTypes_eKinematic: eDynamicTypes = 2;
pub type eDynamicTypes = ::std::os::raw::c_int;
pub const eFileIOActions_eAddFileIOAction: eFileIOActions = 1024;
pub const eFileIOActions_eRemoveFileIOAction: eFileIOActions = 1025;
pub type eFileIOActions = ::std::os::raw::c_int;
pub const eFileIOTypes_ePosixFileIO: eFileIOTypes = 1;
pub const eFileIOTypes_eZipFileIO: eFileIOTypes = 2;
pub const eFileIOTypes_eCNSFileIO: eFileIOTypes = 3;
pub const eFileIOTypes_eInMemoryFileIO: eFileIOTypes = 4;
pub type eFileIOTypes = ::std::os::raw::c_int;
pub const eEnumUpdateVisualShapeFlags_eVISUAL_SHAPE_DOUBLE_SIDED: eEnumUpdateVisualShapeFlags = 4;
pub type eEnumUpdateVisualShapeFlags = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3PhysicsClientHandle__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_b3PhysicsClientHandle__() {
    const UNINIT: ::std::mem::MaybeUninit<b3PhysicsClientHandle__> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<b3PhysicsClientHandle__>(),
        4usize,
        concat!("Size of: ", stringify!(b3PhysicsClientHandle__))
    );
    assert_eq!(
        ::std::mem::align_of::<b3PhysicsClientHandle__>(),
        4usize,
        concat!("Alignment of ", stringify!(b3PhysicsClientHandle__))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(b3PhysicsClientHandle__),
            "::",
            stringify!(unused)
        )
    );
}
pub type b3PhysicsClientHandle = *mut b3PhysicsClientHandle__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3SharedMemoryCommandHandle__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_b3SharedMemoryCommandHandle__() {
    const UNINIT: ::std::mem::MaybeUninit<b3SharedMemoryCommandHandle__> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<b3SharedMemoryCommandHandle__>(),
        4usize,
        concat!("Size of: ", stringify!(b3SharedMemoryCommandHandle__))
    );
    assert_eq!(
        ::std::mem::align_of::<b3SharedMemoryCommandHandle__>(),
        4usize,
        concat!("Alignment of ", stringify!(b3SharedMemoryCommandHandle__))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(b3SharedMemoryCommandHandle__),
            "::",
            stringify!(unused)
        )
    );
}
pub type b3SharedMemoryCommandHandle = *mut b3SharedMemoryCommandHandle__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b3SharedMemoryStatusHandle__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_b3SharedMemoryStatusHandle__() {
    const UNINIT: ::std::mem::MaybeUninit<b3SharedMemoryStatusHandle__> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<b3SharedMemoryStatusHandle__>(),
        4usize,
        concat!("Size of: ", stringify!(b3SharedMemoryStatusHandle__))
    );
    assert_eq!(
        ::std::mem::align_of::<b3SharedMemoryStatusHandle__>(),
        4usize,
        concat!("Alignment of ", stringify!(b3SharedMemoryStatusHandle__))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(b3SharedMemoryStatusHandle__),
            "::",
            stringify!(unused)
        )
    );
}
pub type b3SharedMemoryStatusHandle = *mut b3SharedMemoryStatusHandle__;
extern "C" {
    pub fn b3ConnectSharedMemory(key: ::std::os::raw::c_int) -> b3PhysicsClientHandle;
}
extern "C" {
    pub fn b3ConnectSharedMemory2(key: ::std::os::raw::c_int) -> b3PhysicsClientHandle;
}
extern "C" {
    #[doc = "think more about naming. Directly execute commands without transport (no shared memory, UDP, socket, grpc etc)"]
    pub fn b3ConnectPhysicsDirect() -> b3PhysicsClientHandle;
}
extern "C" {
    #[doc = "b3DisconnectSharedMemory will disconnect the client from the server and cleanup memory."]
    pub fn b3DisconnectSharedMemory(physClient: b3PhysicsClientHandle);
}
extern "C" {
    #[doc = "There can only be 1 outstanding command. Check if a command can be send."]
    pub fn b3CanSubmitCommand(physClient: b3PhysicsClientHandle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "blocking submit command and wait for status"]
    pub fn b3SubmitClientCommandAndWaitStatus(
        physClient: b3PhysicsClientHandle,
        commandHandle: b3SharedMemoryCommandHandle,
    ) -> b3SharedMemoryStatusHandle;
}
extern "C" {
    #[doc = "In general it is better to use b3SubmitClientCommandAndWaitStatus. b3SubmitClientCommand is a non-blocking submit\ncommand, which requires checking for the status manually, using b3ProcessServerStatus. Also, before sending the\nnext command, make sure to check if you can send a command using 'b3CanSubmitCommand'."]
    pub fn b3SubmitClientCommand(
        physClient: b3PhysicsClientHandle,
        commandHandle: b3SharedMemoryCommandHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "non-blocking check status"]
    pub fn b3ProcessServerStatus(physClient: b3PhysicsClientHandle) -> b3SharedMemoryStatusHandle;
}
extern "C" {
    #[doc = " Get the physics server return status type. See EnumSharedMemoryServerStatus in SharedMemoryPublic.h for error codes."]
    pub fn b3GetStatusType(statusHandle: b3SharedMemoryStatusHandle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Plugin system, load and unload a plugin, execute a command"]
    pub fn b3CreateCustomCommand(physClient: b3PhysicsClientHandle) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3CustomCommandLoadPlugin(
        commandHandle: b3SharedMemoryCommandHandle,
        pluginPath: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn b3CustomCommandLoadPluginSetPostFix(
        commandHandle: b3SharedMemoryCommandHandle,
        postFix: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn b3GetStatusPluginUniqueId(
        statusHandle: b3SharedMemoryStatusHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3GetStatusPluginCommandResult(
        statusHandle: b3SharedMemoryStatusHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3GetStatusPluginCommandReturnData(
        physClient: b3PhysicsClientHandle,
        valueOut: *mut b3UserDataValue,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CustomCommandUnloadPlugin(
        commandHandle: b3SharedMemoryCommandHandle,
        pluginUniqueId: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn b3CustomCommandExecutePluginCommand(
        commandHandle: b3SharedMemoryCommandHandle,
        pluginUniqueId: ::std::os::raw::c_int,
        textArguments: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn b3CustomCommandExecuteAddIntArgument(
        commandHandle: b3SharedMemoryCommandHandle,
        intVal: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn b3CustomCommandExecuteAddFloatArgument(
        commandHandle: b3SharedMemoryCommandHandle,
        floatVal: f32,
    );
}
extern "C" {
    pub fn b3GetStatusBodyIndices(
        statusHandle: b3SharedMemoryStatusHandle,
        bodyIndicesOut: *mut ::std::os::raw::c_int,
        bodyIndicesCapacity: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3GetStatusBodyIndex(statusHandle: b3SharedMemoryStatusHandle) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3GetStatusActualState(
        statusHandle: b3SharedMemoryStatusHandle,
        bodyUniqueId: *mut ::std::os::raw::c_int,
        numDegreeOfFreedomQ: *mut ::std::os::raw::c_int,
        numDegreeOfFreedomU: *mut ::std::os::raw::c_int,
        rootLocalInertialFrame: *mut *const f64,
        actualStateQ: *mut *const f64,
        actualStateQdot: *mut *const f64,
        jointReactionForces: *mut *const f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3GetStatusActualState2(
        statusHandle: b3SharedMemoryStatusHandle,
        bodyUniqueId: *mut ::std::os::raw::c_int,
        numLinks: *mut ::std::os::raw::c_int,
        numDegreeOfFreedomQ: *mut ::std::os::raw::c_int,
        numDegreeOfFreedomU: *mut ::std::os::raw::c_int,
        rootLocalInertialFrame: *mut *const f64,
        actualStateQ: *mut *const f64,
        actualStateQdot: *mut *const f64,
        jointReactionForces: *mut *const f64,
        linkLocalInertialFrames: *mut *const f64,
        jointMotorForces: *mut *const f64,
        linkStates: *mut *const f64,
        linkWorldVelocities: *mut *const f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3RequestCollisionInfoCommandInit(
        physClient: b3PhysicsClientHandle,
        bodyUniqueId: ::std::os::raw::c_int,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3GetStatusAABB(
        statusHandle: b3SharedMemoryStatusHandle,
        linkIndex: ::std::os::raw::c_int,
        aabbMin: *mut f64,
        aabbMax: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "If you re-connected to an existing server, or server changed otherwise, sync the body info and user constraints etc."]
    pub fn b3InitSyncBodyInfoCommand(
        physClient: b3PhysicsClientHandle,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3InitRequestBodyInfoCommand(
        physClient: b3PhysicsClientHandle,
        bodyUniqueId: ::std::os::raw::c_int,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3InitRemoveBodyCommand(
        physClient: b3PhysicsClientHandle,
        bodyUniqueId: ::std::os::raw::c_int,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    #[doc = "return the total number of bodies in the simulation"]
    pub fn b3GetNumBodies(physClient: b3PhysicsClientHandle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " return the body unique id, given the index in range [0 , b3GetNumBodies() )"]
    pub fn b3GetBodyUniqueId(
        physClient: b3PhysicsClientHandle,
        serialIndex: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "given a body unique id, return the body information. See b3BodyInfo in SharedMemoryPublic.h"]
    pub fn b3GetBodyInfo(
        physClient: b3PhysicsClientHandle,
        bodyUniqueId: ::std::os::raw::c_int,
        info: *mut b3BodyInfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "give a unique body index (after loading the body) return the number of joints."]
    pub fn b3GetNumJoints(
        physClient: b3PhysicsClientHandle,
        bodyUniqueId: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "give a unique body index (after loading the body) return the number of degrees of freedom (DoF)."]
    pub fn b3GetNumDofs(
        physClient: b3PhysicsClientHandle,
        bodyUniqueId: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "compute the number of degrees of freedom for this body.\nReturn -1 for unsupported spherical joint, -2 for unsupported planar joint."]
    pub fn b3ComputeDofCount(
        physClient: b3PhysicsClientHandle,
        bodyUniqueId: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "given a body and joint index, return the joint information. See b3JointInfo in SharedMemoryPublic.h"]
    pub fn b3GetJointInfo(
        physClient: b3PhysicsClientHandle,
        bodyUniqueId: ::std::os::raw::c_int,
        jointIndex: ::std::os::raw::c_int,
        info: *mut b3JointInfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "user data handling"]
    pub fn b3InitSyncUserDataCommand(
        physClient: b3PhysicsClientHandle,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3AddBodyToSyncUserDataRequest(
        commandHandle: b3SharedMemoryCommandHandle,
        bodyUniqueId: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn b3InitAddUserDataCommand(
        physClient: b3PhysicsClientHandle,
        bodyUniqueId: ::std::os::raw::c_int,
        linkIndex: ::std::os::raw::c_int,
        visualShapeIndex: ::std::os::raw::c_int,
        key: *const ::std::os::raw::c_char,
        valueType: UserDataValueType,
        valueLength: ::std::os::raw::c_int,
        valueData: *const ::std::os::raw::c_void,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3InitRemoveUserDataCommand(
        physClient: b3PhysicsClientHandle,
        userDataId: ::std::os::raw::c_int,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3GetUserData(
        physClient: b3PhysicsClientHandle,
        userDataId: ::std::os::raw::c_int,
        valueOut: *mut b3UserDataValue,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3GetUserDataId(
        physClient: b3PhysicsClientHandle,
        bodyUniqueId: ::std::os::raw::c_int,
        linkIndex: ::std::os::raw::c_int,
        visualShapeIndex: ::std::os::raw::c_int,
        key: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3GetUserDataIdFromStatus(
        statusHandle: b3SharedMemoryStatusHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3GetNumUserData(
        physClient: b3PhysicsClientHandle,
        bodyUniqueId: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3GetUserDataInfo(
        physClient: b3PhysicsClientHandle,
        bodyUniqueId: ::std::os::raw::c_int,
        userDataIndex: ::std::os::raw::c_int,
        keyOut: *mut *const ::std::os::raw::c_char,
        userDataIdOut: *mut ::std::os::raw::c_int,
        linkIndexOut: *mut ::std::os::raw::c_int,
        visualShapeIndexOut: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn b3GetDynamicsInfoCommandInit(
        physClient: b3PhysicsClientHandle,
        bodyUniqueId: ::std::os::raw::c_int,
        linkIndex: ::std::os::raw::c_int,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3GetDynamicsInfoCommandInit2(
        commandHandle: b3SharedMemoryCommandHandle,
        bodyUniqueId: ::std::os::raw::c_int,
        linkIndex: ::std::os::raw::c_int,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    #[doc = "given a body unique id and link index, return the dynamics information. See b3DynamicsInfo in SharedMemoryPublic.h"]
    pub fn b3GetDynamicsInfo(
        statusHandle: b3SharedMemoryStatusHandle,
        info: *mut b3DynamicsInfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3InitChangeDynamicsInfo(
        physClient: b3PhysicsClientHandle,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3InitChangeDynamicsInfo2(
        commandHandle: b3SharedMemoryCommandHandle,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3ChangeDynamicsInfoSetMass(
        commandHandle: b3SharedMemoryCommandHandle,
        bodyUniqueId: ::std::os::raw::c_int,
        linkIndex: ::std::os::raw::c_int,
        mass: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3ChangeDynamicsInfoSetLocalInertiaDiagonal(
        commandHandle: b3SharedMemoryCommandHandle,
        bodyUniqueId: ::std::os::raw::c_int,
        linkIndex: ::std::os::raw::c_int,
        localInertiaDiagonal: *const f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3ChangeDynamicsInfoSetAnisotropicFriction(
        commandHandle: b3SharedMemoryCommandHandle,
        bodyUniqueId: ::std::os::raw::c_int,
        linkIndex: ::std::os::raw::c_int,
        anisotropicFriction: *const f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3ChangeDynamicsInfoSetJointLimit(
        commandHandle: b3SharedMemoryCommandHandle,
        bodyUniqueId: ::std::os::raw::c_int,
        linkIndex: ::std::os::raw::c_int,
        jointLowerLimit: f64,
        jointUpperLimit: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3ChangeDynamicsInfoSetJointLimitForce(
        commandHandle: b3SharedMemoryCommandHandle,
        bodyUniqueId: ::std::os::raw::c_int,
        linkIndex: ::std::os::raw::c_int,
        jointLimitForce: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3ChangeDynamicsInfoSetDynamicType(
        commandHandle: b3SharedMemoryCommandHandle,
        bodyUniqueId: ::std::os::raw::c_int,
        linkIndex: ::std::os::raw::c_int,
        dynamicType: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3ChangeDynamicsInfoSetSleepThreshold(
        commandHandle: b3SharedMemoryCommandHandle,
        bodyUniqueId: ::std::os::raw::c_int,
        sleepThreshold: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3ChangeDynamicsInfoSetLateralFriction(
        commandHandle: b3SharedMemoryCommandHandle,
        bodyUniqueId: ::std::os::raw::c_int,
        linkIndex: ::std::os::raw::c_int,
        lateralFriction: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3ChangeDynamicsInfoSetSpinningFriction(
        commandHandle: b3SharedMemoryCommandHandle,
        bodyUniqueId: ::std::os::raw::c_int,
        linkIndex: ::std::os::raw::c_int,
        friction: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3ChangeDynamicsInfoSetRollingFriction(
        commandHandle: b3SharedMemoryCommandHandle,
        bodyUniqueId: ::std::os::raw::c_int,
        linkIndex: ::std::os::raw::c_int,
        friction: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3ChangeDynamicsInfoSetRestitution(
        commandHandle: b3SharedMemoryCommandHandle,
        bodyUniqueId: ::std::os::raw::c_int,
        linkIndex: ::std::os::raw::c_int,
        restitution: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3ChangeDynamicsInfoSetLinearDamping(
        commandHandle: b3SharedMemoryCommandHandle,
        bodyUniqueId: ::std::os::raw::c_int,
        linearDamping: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3ChangeDynamicsInfoSetAngularDamping(
        commandHandle: b3SharedMemoryCommandHandle,
        bodyUniqueId: ::std::os::raw::c_int,
        angularDamping: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3ChangeDynamicsInfoSetJointDamping(
        commandHandle: b3SharedMemoryCommandHandle,
        bodyUniqueId: ::std::os::raw::c_int,
        linkIndex: ::std::os::raw::c_int,
        jointDamping: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3ChangeDynamicsInfoSetContactStiffnessAndDamping(
        commandHandle: b3SharedMemoryCommandHandle,
        bodyUniqueId: ::std::os::raw::c_int,
        linkIndex: ::std::os::raw::c_int,
        contactStiffness: f64,
        contactDamping: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3ChangeDynamicsInfoSetFrictionAnchor(
        commandHandle: b3SharedMemoryCommandHandle,
        bodyUniqueId: ::std::os::raw::c_int,
        linkIndex: ::std::os::raw::c_int,
        frictionAnchor: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3ChangeDynamicsInfoSetCcdSweptSphereRadius(
        commandHandle: b3SharedMemoryCommandHandle,
        bodyUniqueId: ::std::os::raw::c_int,
        linkIndex: ::std::os::raw::c_int,
        ccdSweptSphereRadius: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3ChangeDynamicsInfoSetContactProcessingThreshold(
        commandHandle: b3SharedMemoryCommandHandle,
        bodyUniqueId: ::std::os::raw::c_int,
        linkIndex: ::std::os::raw::c_int,
        contactProcessingThreshold: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3ChangeDynamicsInfoSetActivationState(
        commandHandle: b3SharedMemoryCommandHandle,
        bodyUniqueId: ::std::os::raw::c_int,
        activationState: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3ChangeDynamicsInfoSetMaxJointVelocity(
        commandHandle: b3SharedMemoryCommandHandle,
        bodyUniqueId: ::std::os::raw::c_int,
        maxJointVelocity: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3ChangeDynamicsInfoSetCollisionMargin(
        commandHandle: b3SharedMemoryCommandHandle,
        bodyUniqueId: ::std::os::raw::c_int,
        collisionMargin: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3InitCreateUserConstraintCommand(
        physClient: b3PhysicsClientHandle,
        parentBodyUniqueId: ::std::os::raw::c_int,
        parentJointIndex: ::std::os::raw::c_int,
        childBodyUniqueId: ::std::os::raw::c_int,
        childJointIndex: ::std::os::raw::c_int,
        info: *mut b3JointInfo,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3InitCreateUserConstraintCommand2(
        commandHandle: b3SharedMemoryCommandHandle,
        parentBodyUniqueId: ::std::os::raw::c_int,
        parentJointIndex: ::std::os::raw::c_int,
        childBodyUniqueId: ::std::os::raw::c_int,
        childJointIndex: ::std::os::raw::c_int,
        info: *mut b3JointInfo,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    #[doc = "return a unique id for the user constraint, after successful creation, or -1 for an invalid constraint id"]
    pub fn b3GetStatusUserConstraintUniqueId(
        statusHandle: b3SharedMemoryStatusHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "change parameters of an existing user constraint"]
    pub fn b3InitChangeUserConstraintCommand(
        physClient: b3PhysicsClientHandle,
        userConstraintUniqueId: ::std::os::raw::c_int,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3InitChangeUserConstraintSetPivotInB(
        commandHandle: b3SharedMemoryCommandHandle,
        jointChildPivot: *const f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3InitChangeUserConstraintSetFrameInB(
        commandHandle: b3SharedMemoryCommandHandle,
        jointChildFrameOrn: *const f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3InitChangeUserConstraintSetMaxForce(
        commandHandle: b3SharedMemoryCommandHandle,
        maxAppliedForce: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3InitChangeUserConstraintSetGearRatio(
        commandHandle: b3SharedMemoryCommandHandle,
        gearRatio: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3InitChangeUserConstraintSetGearAuxLink(
        commandHandle: b3SharedMemoryCommandHandle,
        gearAuxLink: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3InitChangeUserConstraintSetRelativePositionTarget(
        commandHandle: b3SharedMemoryCommandHandle,
        relativePositionTarget: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3InitChangeUserConstraintSetERP(
        commandHandle: b3SharedMemoryCommandHandle,
        erp: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3InitRemoveUserConstraintCommand(
        physClient: b3PhysicsClientHandle,
        userConstraintUniqueId: ::std::os::raw::c_int,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3GetNumUserConstraints(physClient: b3PhysicsClientHandle) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3InitGetUserConstraintStateCommand(
        physClient: b3PhysicsClientHandle,
        constraintUniqueId: ::std::os::raw::c_int,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3GetStatusUserConstraintState(
        statusHandle: b3SharedMemoryStatusHandle,
        constraintState: *mut b3UserConstraintState,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3GetUserConstraintInfo(
        physClient: b3PhysicsClientHandle,
        constraintUniqueId: ::std::os::raw::c_int,
        info: *mut b3UserConstraint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " return the user constraint id, given the index in range [0 , b3GetNumUserConstraints() )"]
    pub fn b3GetUserConstraintId(
        physClient: b3PhysicsClientHandle,
        serialIndex: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Request physics debug lines for debug visualization. The flags in debugMode are the same as used in Bullet\nSee btIDebugDraw::DebugDrawModes in Bullet/src/LinearMath/btIDebugDraw.h"]
    pub fn b3InitRequestDebugLinesCommand(
        physClient: b3PhysicsClientHandle,
        debugMode: ::std::os::raw::c_int,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    #[doc = "Get the pointers to the physics debug line information, after b3InitRequestDebugLinesCommand returns\nstatus CMD_DEBUG_LINES_COMPLETED"]
    pub fn b3GetDebugLines(physClient: b3PhysicsClientHandle, lines: *mut b3DebugLines);
}
extern "C" {
    #[doc = "configure the 3D OpenGL debug visualizer (enable/disable GUI widgets, shadows, position camera etc)"]
    pub fn b3InitConfigureOpenGLVisualizer(
        physClient: b3PhysicsClientHandle,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3InitConfigureOpenGLVisualizer2(
        commandHandle: b3SharedMemoryCommandHandle,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3ConfigureOpenGLVisualizerSetVisualizationFlags(
        commandHandle: b3SharedMemoryCommandHandle,
        flag: ::std::os::raw::c_int,
        enabled: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn b3ConfigureOpenGLVisualizerSetLightPosition(
        commandHandle: b3SharedMemoryCommandHandle,
        lightPosition: *const f32,
    );
}
extern "C" {
    pub fn b3ConfigureOpenGLVisualizerSetShadowMapResolution(
        commandHandle: b3SharedMemoryCommandHandle,
        shadowMapResolution: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn b3ConfigureOpenGLVisualizerSetShadowMapIntensity(
        commandHandle: b3SharedMemoryCommandHandle,
        shadowMapIntensity: f64,
    );
}
extern "C" {
    pub fn b3ConfigureOpenGLVisualizerSetLightRgbBackground(
        commandHandle: b3SharedMemoryCommandHandle,
        rgbBackground: *const f32,
    );
}
extern "C" {
    pub fn b3ConfigureOpenGLVisualizerSetShadowMapWorldSize(
        commandHandle: b3SharedMemoryCommandHandle,
        shadowMapWorldSize: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn b3ConfigureOpenGLVisualizerSetRemoteSyncTransformInterval(
        commandHandle: b3SharedMemoryCommandHandle,
        remoteSyncTransformInterval: f64,
    );
}
extern "C" {
    pub fn b3ConfigureOpenGLVisualizerSetViewMatrix(
        commandHandle: b3SharedMemoryCommandHandle,
        cameraDistance: f32,
        cameraPitch: f32,
        cameraYaw: f32,
        cameraTargetPosition: *const f32,
    );
}
extern "C" {
    pub fn b3InitRequestOpenGLVisualizerCameraCommand(
        physClient: b3PhysicsClientHandle,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3GetStatusOpenGLVisualizerCamera(
        statusHandle: b3SharedMemoryStatusHandle,
        camera: *mut b3OpenGLVisualizerCameraInfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add/remove user-specific debug lines and debug text messages"]
    pub fn b3InitUserDebugDrawAddLine3D(
        physClient: b3PhysicsClientHandle,
        fromXYZ: *const f64,
        toXYZ: *const f64,
        colorRGB: *const f64,
        lineWidth: f64,
        lifeTime: f64,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3InitUserDebugDrawAddPoints3D(
        physClient: b3PhysicsClientHandle,
        positionsXYZ: *const f64,
        colorsRGB: *const f64,
        pointSize: f64,
        lifeTime: f64,
        pointNum: ::std::os::raw::c_int,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3InitUserDebugDrawAddText3D(
        physClient: b3PhysicsClientHandle,
        txt: *const ::std::os::raw::c_char,
        positionXYZ: *const f64,
        colorRGB: *const f64,
        textSize: f64,
        lifeTime: f64,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3UserDebugTextSetOptionFlags(
        commandHandle: b3SharedMemoryCommandHandle,
        optionFlags: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn b3UserDebugTextSetOrientation(
        commandHandle: b3SharedMemoryCommandHandle,
        orientation: *const f64,
    );
}
extern "C" {
    pub fn b3UserDebugItemSetReplaceItemUniqueId(
        commandHandle: b3SharedMemoryCommandHandle,
        replaceItem: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn b3UserDebugItemSetParentObject(
        commandHandle: b3SharedMemoryCommandHandle,
        objectUniqueId: ::std::os::raw::c_int,
        linkIndex: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn b3InitUserDebugAddParameter(
        physClient: b3PhysicsClientHandle,
        txt: *const ::std::os::raw::c_char,
        rangeMin: f64,
        rangeMax: f64,
        startValue: f64,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3InitUserDebugReadParameter(
        physClient: b3PhysicsClientHandle,
        debugItemUniqueId: ::std::os::raw::c_int,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3GetStatusDebugParameterValue(
        statusHandle: b3SharedMemoryStatusHandle,
        paramValue: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3InitUserDebugDrawRemove(
        physClient: b3PhysicsClientHandle,
        debugItemUniqueId: ::std::os::raw::c_int,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3InitUserDebugDrawRemoveAll(
        physClient: b3PhysicsClientHandle,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3InitUserRemoveAllParameters(
        physClient: b3PhysicsClientHandle,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3InitDebugDrawingCommand(
        physClient: b3PhysicsClientHandle,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3SetDebugObjectColor(
        commandHandle: b3SharedMemoryCommandHandle,
        objectUniqueId: ::std::os::raw::c_int,
        linkIndex: ::std::os::raw::c_int,
        objectColorRGB: *const f64,
    );
}
extern "C" {
    pub fn b3RemoveDebugObjectColor(
        commandHandle: b3SharedMemoryCommandHandle,
        objectUniqueId: ::std::os::raw::c_int,
        linkIndex: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = "All debug items unique Ids are positive: a negative unique Id means failure."]
    pub fn b3GetDebugItemUniqueId(
        statusHandle: b3SharedMemoryStatusHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "request an image from a simulated camera, using a software renderer."]
    pub fn b3InitRequestCameraImage(
        physClient: b3PhysicsClientHandle,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3InitRequestCameraImage2(
        commandHandle: b3SharedMemoryCommandHandle,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3RequestCameraImageSetCameraMatrices(
        commandHandle: b3SharedMemoryCommandHandle,
        viewMatrix: *mut f32,
        projectionMatrix: *mut f32,
    );
}
extern "C" {
    pub fn b3RequestCameraImageSetPixelResolution(
        commandHandle: b3SharedMemoryCommandHandle,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn b3RequestCameraImageSetLightDirection(
        commandHandle: b3SharedMemoryCommandHandle,
        lightDirection: *const f32,
    );
}
extern "C" {
    pub fn b3RequestCameraImageSetLightColor(
        commandHandle: b3SharedMemoryCommandHandle,
        lightColor: *const f32,
    );
}
extern "C" {
    pub fn b3RequestCameraImageSetLightDistance(
        commandHandle: b3SharedMemoryCommandHandle,
        lightDistance: f32,
    );
}
extern "C" {
    pub fn b3RequestCameraImageSetLightAmbientCoeff(
        commandHandle: b3SharedMemoryCommandHandle,
        lightAmbientCoeff: f32,
    );
}
extern "C" {
    pub fn b3RequestCameraImageSetLightDiffuseCoeff(
        commandHandle: b3SharedMemoryCommandHandle,
        lightDiffuseCoeff: f32,
    );
}
extern "C" {
    pub fn b3RequestCameraImageSetLightSpecularCoeff(
        commandHandle: b3SharedMemoryCommandHandle,
        lightSpecularCoeff: f32,
    );
}
extern "C" {
    pub fn b3RequestCameraImageSetShadow(
        commandHandle: b3SharedMemoryCommandHandle,
        hasShadow: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn b3RequestCameraImageSelectRenderer(
        commandHandle: b3SharedMemoryCommandHandle,
        renderer: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn b3RequestCameraImageSetFlags(
        commandHandle: b3SharedMemoryCommandHandle,
        flags: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn b3GetCameraImageData(
        physClient: b3PhysicsClientHandle,
        imageData: *mut b3CameraImageData,
    );
}
extern "C" {
    #[doc = "set projective texture camera matrices."]
    pub fn b3RequestCameraImageSetProjectiveTextureMatrices(
        commandHandle: b3SharedMemoryCommandHandle,
        viewMatrix: *mut f32,
        projectionMatrix: *mut f32,
    );
}
extern "C" {
    #[doc = "compute a view matrix, helper function for b3RequestCameraImageSetCameraMatrices"]
    pub fn b3ComputeViewMatrixFromPositions(
        cameraPosition: *const f32,
        cameraTargetPosition: *const f32,
        cameraUp: *const f32,
        viewMatrix: *mut f32,
    );
}
extern "C" {
    pub fn b3ComputeViewMatrixFromYawPitchRoll(
        cameraTargetPosition: *const f32,
        distance: f32,
        yaw: f32,
        pitch: f32,
        roll: f32,
        upAxis: ::std::os::raw::c_int,
        viewMatrix: *mut f32,
    );
}
extern "C" {
    pub fn b3ComputePositionFromViewMatrix(
        viewMatrix: *const f32,
        cameraPosition: *mut f32,
        cameraTargetPosition: *mut f32,
        cameraUp: *mut f32,
    );
}
extern "C" {
    #[doc = "compute a projection matrix, helper function for b3RequestCameraImageSetCameraMatrices"]
    pub fn b3ComputeProjectionMatrix(
        left: f32,
        right: f32,
        bottom: f32,
        top: f32,
        nearVal: f32,
        farVal: f32,
        projectionMatrix: *mut f32,
    );
}
extern "C" {
    pub fn b3ComputeProjectionMatrixFOV(
        fov: f32,
        aspect: f32,
        nearVal: f32,
        farVal: f32,
        projectionMatrix: *mut f32,
    );
}
extern "C" {
    pub fn b3RequestCameraImageSetViewMatrix(
        commandHandle: b3SharedMemoryCommandHandle,
        cameraPosition: *const f32,
        cameraTargetPosition: *const f32,
        cameraUp: *const f32,
    );
}
extern "C" {
    pub fn b3RequestCameraImageSetViewMatrix2(
        commandHandle: b3SharedMemoryCommandHandle,
        cameraTargetPosition: *const f32,
        distance: f32,
        yaw: f32,
        pitch: f32,
        roll: f32,
        upAxis: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn b3RequestCameraImageSetProjectionMatrix(
        commandHandle: b3SharedMemoryCommandHandle,
        left: f32,
        right: f32,
        bottom: f32,
        top: f32,
        nearVal: f32,
        farVal: f32,
    );
}
extern "C" {
    pub fn b3RequestCameraImageSetFOVProjectionMatrix(
        commandHandle: b3SharedMemoryCommandHandle,
        fov: f32,
        aspect: f32,
        nearVal: f32,
        farVal: f32,
    );
}
extern "C" {
    #[doc = "request an contact point information"]
    pub fn b3InitRequestContactPointInformation(
        physClient: b3PhysicsClientHandle,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3SetContactFilterBodyA(
        commandHandle: b3SharedMemoryCommandHandle,
        bodyUniqueIdA: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn b3SetContactFilterBodyB(
        commandHandle: b3SharedMemoryCommandHandle,
        bodyUniqueIdB: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn b3SetContactFilterLinkA(
        commandHandle: b3SharedMemoryCommandHandle,
        linkIndexA: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn b3SetContactFilterLinkB(
        commandHandle: b3SharedMemoryCommandHandle,
        linkIndexB: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn b3GetContactPointInformation(
        physClient: b3PhysicsClientHandle,
        contactPointData: *mut b3ContactInformation,
    );
}
extern "C" {
    #[doc = "compute the closest points between two bodies"]
    pub fn b3InitClosestDistanceQuery(
        physClient: b3PhysicsClientHandle,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3SetClosestDistanceFilterBodyA(
        commandHandle: b3SharedMemoryCommandHandle,
        bodyUniqueIdA: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn b3SetClosestDistanceFilterLinkA(
        commandHandle: b3SharedMemoryCommandHandle,
        linkIndexA: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn b3SetClosestDistanceFilterBodyB(
        commandHandle: b3SharedMemoryCommandHandle,
        bodyUniqueIdB: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn b3SetClosestDistanceFilterLinkB(
        commandHandle: b3SharedMemoryCommandHandle,
        linkIndexB: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn b3SetClosestDistanceThreshold(commandHandle: b3SharedMemoryCommandHandle, distance: f64);
}
extern "C" {
    pub fn b3SetClosestDistanceFilterCollisionShapeA(
        commandHandle: b3SharedMemoryCommandHandle,
        collisionShapeA: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn b3SetClosestDistanceFilterCollisionShapeB(
        commandHandle: b3SharedMemoryCommandHandle,
        collisionShapeB: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn b3SetClosestDistanceFilterCollisionShapePositionA(
        commandHandle: b3SharedMemoryCommandHandle,
        collisionShapePositionA: *const f64,
    );
}
extern "C" {
    pub fn b3SetClosestDistanceFilterCollisionShapePositionB(
        commandHandle: b3SharedMemoryCommandHandle,
        collisionShapePositionB: *const f64,
    );
}
extern "C" {
    pub fn b3SetClosestDistanceFilterCollisionShapeOrientationA(
        commandHandle: b3SharedMemoryCommandHandle,
        collisionShapeOrientationA: *const f64,
    );
}
extern "C" {
    pub fn b3SetClosestDistanceFilterCollisionShapeOrientationB(
        commandHandle: b3SharedMemoryCommandHandle,
        collisionShapeOrientationB: *const f64,
    );
}
extern "C" {
    pub fn b3GetClosestPointInformation(
        physClient: b3PhysicsClientHandle,
        contactPointInfo: *mut b3ContactInformation,
    );
}
extern "C" {
    #[doc = "get all the bodies that touch a given axis aligned bounding box specified in world space (min and max coordinates)"]
    pub fn b3InitAABBOverlapQuery(
        physClient: b3PhysicsClientHandle,
        aabbMin: *const f64,
        aabbMax: *const f64,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3GetAABBOverlapResults(physClient: b3PhysicsClientHandle, data: *mut b3AABBOverlapData);
}
extern "C" {
    pub fn b3InitRequestVisualShapeInformation(
        physClient: b3PhysicsClientHandle,
        bodyUniqueIdA: ::std::os::raw::c_int,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3GetVisualShapeInformation(
        physClient: b3PhysicsClientHandle,
        visualShapeInfo: *mut b3VisualShapeInformation,
    );
}
extern "C" {
    pub fn b3InitRequestCollisionShapeInformation(
        physClient: b3PhysicsClientHandle,
        bodyUniqueId: ::std::os::raw::c_int,
        linkIndex: ::std::os::raw::c_int,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3GetCollisionShapeInformation(
        physClient: b3PhysicsClientHandle,
        collisionShapeInfo: *mut b3CollisionShapeInformation,
    );
}
extern "C" {
    pub fn b3InitLoadTexture(
        physClient: b3PhysicsClientHandle,
        filename: *const ::std::os::raw::c_char,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3GetStatusTextureUniqueId(
        statusHandle: b3SharedMemoryStatusHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CreateChangeTextureCommandInit(
        physClient: b3PhysicsClientHandle,
        textureUniqueId: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        rgbPixels: *const ::std::os::raw::c_char,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3InitUpdateVisualShape(
        physClient: b3PhysicsClientHandle,
        bodyUniqueId: ::std::os::raw::c_int,
        jointIndex: ::std::os::raw::c_int,
        shapeIndex: ::std::os::raw::c_int,
        textureUniqueId: ::std::os::raw::c_int,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3InitUpdateVisualShape2(
        physClient: b3PhysicsClientHandle,
        bodyUniqueId: ::std::os::raw::c_int,
        jointIndex: ::std::os::raw::c_int,
        shapeIndex: ::std::os::raw::c_int,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3UpdateVisualShapeTexture(
        commandHandle: b3SharedMemoryCommandHandle,
        textureUniqueId: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn b3UpdateVisualShapeRGBAColor(
        commandHandle: b3SharedMemoryCommandHandle,
        rgbaColor: *const f64,
    );
}
extern "C" {
    pub fn b3UpdateVisualShapeFlags(
        commandHandle: b3SharedMemoryCommandHandle,
        flags: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn b3UpdateVisualShapeSpecularColor(
        commandHandle: b3SharedMemoryCommandHandle,
        specularColor: *const f64,
    );
}
extern "C" {
    pub fn b3InitPhysicsParamCommand(
        physClient: b3PhysicsClientHandle,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3InitPhysicsParamCommand2(
        commandHandle: b3SharedMemoryCommandHandle,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3PhysicsParamSetGravity(
        commandHandle: b3SharedMemoryCommandHandle,
        gravx: f64,
        gravy: f64,
        gravz: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3PhysicsParamSetTimeStep(
        commandHandle: b3SharedMemoryCommandHandle,
        timeStep: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3PhysicsParamSetDefaultContactERP(
        commandHandle: b3SharedMemoryCommandHandle,
        defaultContactERP: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3PhysicsParamSetDefaultNonContactERP(
        commandHandle: b3SharedMemoryCommandHandle,
        defaultNonContactERP: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3PhysicsParamSetDefaultFrictionERP(
        commandHandle: b3SharedMemoryCommandHandle,
        frictionERP: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3PhysicsParamSetDefaultGlobalCFM(
        commandHandle: b3SharedMemoryCommandHandle,
        defaultGlobalCFM: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3PhysicsParamSetDefaultFrictionCFM(
        commandHandle: b3SharedMemoryCommandHandle,
        frictionCFM: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3PhysicsParamSetNumSubSteps(
        commandHandle: b3SharedMemoryCommandHandle,
        numSubSteps: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3PhysicsParamSetRealTimeSimulation(
        commandHandle: b3SharedMemoryCommandHandle,
        enableRealTimeSimulation: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3PhysicsParamSetNumSolverIterations(
        commandHandle: b3SharedMemoryCommandHandle,
        numSolverIterations: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3PhysicsParamSetNumNonContactInnerIterations(
        commandHandle: b3SharedMemoryCommandHandle,
        numMotorIterations: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3PhysicsParamSetWarmStartingFactor(
        commandHandle: b3SharedMemoryCommandHandle,
        warmStartingFactor: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3PhysicsParamSetArticulatedWarmStartingFactor(
        commandHandle: b3SharedMemoryCommandHandle,
        warmStartingFactor: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3PhysicsParamSetCollisionFilterMode(
        commandHandle: b3SharedMemoryCommandHandle,
        filterMode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3PhysicsParamSetUseSplitImpulse(
        commandHandle: b3SharedMemoryCommandHandle,
        useSplitImpulse: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3PhysicsParamSetSplitImpulsePenetrationThreshold(
        commandHandle: b3SharedMemoryCommandHandle,
        splitImpulsePenetrationThreshold: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3PhysicsParamSetContactBreakingThreshold(
        commandHandle: b3SharedMemoryCommandHandle,
        contactBreakingThreshold: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3PhysicsParamSetMaxNumCommandsPer1ms(
        commandHandle: b3SharedMemoryCommandHandle,
        maxNumCmdPer1ms: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3PhysicsParamSetEnableFileCaching(
        commandHandle: b3SharedMemoryCommandHandle,
        enableFileCaching: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3PhysicsParamSetRestitutionVelocityThreshold(
        commandHandle: b3SharedMemoryCommandHandle,
        restitutionVelocityThreshold: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3PhysicsParamSetEnableConeFriction(
        commandHandle: b3SharedMemoryCommandHandle,
        enableConeFriction: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3PhysicsParameterSetDeterministicOverlappingPairs(
        commandHandle: b3SharedMemoryCommandHandle,
        deterministicOverlappingPairs: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3PhysicsParameterSetAllowedCcdPenetration(
        commandHandle: b3SharedMemoryCommandHandle,
        allowedCcdPenetration: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3PhysicsParameterSetJointFeedbackMode(
        commandHandle: b3SharedMemoryCommandHandle,
        jointFeedbackMode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3PhysicsParamSetSolverResidualThreshold(
        commandHandle: b3SharedMemoryCommandHandle,
        solverResidualThreshold: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3PhysicsParamSetContactSlop(
        commandHandle: b3SharedMemoryCommandHandle,
        contactSlop: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3PhysicsParameterSetEnableSAT(
        commandHandle: b3SharedMemoryCommandHandle,
        enableSAT: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3PhysicsParameterSetConstraintSolverType(
        commandHandle: b3SharedMemoryCommandHandle,
        constraintSolverType: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3PhysicsParameterSetMinimumSolverIslandSize(
        commandHandle: b3SharedMemoryCommandHandle,
        minimumSolverIslandSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3PhysicsParamSetSolverAnalytics(
        commandHandle: b3SharedMemoryCommandHandle,
        reportSolverAnalytics: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3PhysicsParameterSetSparseSdfVoxelSize(
        commandHandle: b3SharedMemoryCommandHandle,
        sparseSdfVoxelSize: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3InitRequestPhysicsParamCommand(
        physClient: b3PhysicsClientHandle,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3GetStatusPhysicsSimulationParameters(
        statusHandle: b3SharedMemoryStatusHandle,
        params: *mut b3PhysicsSimulationParameters,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3PhysicsParamSetInternalSimFlags(
        commandHandle: b3SharedMemoryCommandHandle,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3InitStepSimulationCommand(
        physClient: b3PhysicsClientHandle,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3InitStepSimulationCommand2(
        commandHandle: b3SharedMemoryCommandHandle,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3InitPerformCollisionDetectionCommand(
        physClient: b3PhysicsClientHandle,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3GetStatusForwardDynamicsAnalyticsData(
        statusHandle: b3SharedMemoryStatusHandle,
        analyticsData: *mut b3ForwardDynamicsAnalyticsArgs,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3InitResetSimulationCommand(
        physClient: b3PhysicsClientHandle,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3InitResetSimulationCommand2(
        commandHandle: b3SharedMemoryCommandHandle,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3InitResetSimulationSetFlags(
        commandHandle: b3SharedMemoryCommandHandle,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Load a robot from a URDF file. Status type will CMD_URDF_LOADING_COMPLETED.\nAccess the robot from the unique body index, through b3GetStatusBodyIndex(statusHandle);"]
    pub fn b3LoadUrdfCommandInit(
        physClient: b3PhysicsClientHandle,
        urdfFileName: *const ::std::os::raw::c_char,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3LoadUrdfCommandInit2(
        commandHandle: b3SharedMemoryCommandHandle,
        urdfFileName: *const ::std::os::raw::c_char,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3LoadUrdfCommandSetStartPosition(
        commandHandle: b3SharedMemoryCommandHandle,
        startPosX: f64,
        startPosY: f64,
        startPosZ: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3LoadUrdfCommandSetStartOrientation(
        commandHandle: b3SharedMemoryCommandHandle,
        startOrnX: f64,
        startOrnY: f64,
        startOrnZ: f64,
        startOrnW: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3LoadUrdfCommandSetUseMultiBody(
        commandHandle: b3SharedMemoryCommandHandle,
        useMultiBody: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3LoadUrdfCommandSetUseFixedBase(
        commandHandle: b3SharedMemoryCommandHandle,
        useFixedBase: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3LoadUrdfCommandSetFlags(
        commandHandle: b3SharedMemoryCommandHandle,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3LoadUrdfCommandSetGlobalScaling(
        commandHandle: b3SharedMemoryCommandHandle,
        globalScaling: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3SaveStateCommandInit(physClient: b3PhysicsClientHandle)
        -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3InitRemoveStateCommand(
        physClient: b3PhysicsClientHandle,
        stateId: ::std::os::raw::c_int,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3GetStatusGetStateId(statusHandle: b3SharedMemoryStatusHandle)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3LoadStateCommandInit(physClient: b3PhysicsClientHandle)
        -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3LoadStateSetStateId(
        commandHandle: b3SharedMemoryCommandHandle,
        stateId: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3LoadStateSetFileName(
        commandHandle: b3SharedMemoryCommandHandle,
        fileName: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3LoadBulletCommandInit(
        physClient: b3PhysicsClientHandle,
        fileName: *const ::std::os::raw::c_char,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3SaveBulletCommandInit(
        physClient: b3PhysicsClientHandle,
        fileName: *const ::std::os::raw::c_char,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3LoadMJCFCommandInit(
        physClient: b3PhysicsClientHandle,
        fileName: *const ::std::os::raw::c_char,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3LoadMJCFCommandInit2(
        commandHandle: b3SharedMemoryCommandHandle,
        fileName: *const ::std::os::raw::c_char,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3LoadMJCFCommandSetFlags(
        commandHandle: b3SharedMemoryCommandHandle,
        flags: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn b3LoadMJCFCommandSetUseMultiBody(
        commandHandle: b3SharedMemoryCommandHandle,
        useMultiBody: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = "compute the forces to achieve an acceleration, given a state q and qdot using inverse dynamics"]
    pub fn b3CalculateInverseDynamicsCommandInit(
        physClient: b3PhysicsClientHandle,
        bodyUniqueId: ::std::os::raw::c_int,
        jointPositionsQ: *const f64,
        jointVelocitiesQdot: *const f64,
        jointAccelerations: *const f64,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3CalculateInverseDynamicsCommandInit2(
        physClient: b3PhysicsClientHandle,
        bodyUniqueId: ::std::os::raw::c_int,
        jointPositionsQ: *const f64,
        dofCountQ: ::std::os::raw::c_int,
        jointVelocitiesQdot: *const f64,
        jointAccelerations: *const f64,
        dofCountQdot: ::std::os::raw::c_int,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3CalculateInverseDynamicsSetFlags(
        commandHandle: b3SharedMemoryCommandHandle,
        flags: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn b3GetStatusInverseDynamicsJointForces(
        statusHandle: b3SharedMemoryStatusHandle,
        bodyUniqueId: *mut ::std::os::raw::c_int,
        dofCount: *mut ::std::os::raw::c_int,
        jointForces: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CalculateJacobianCommandInit(
        physClient: b3PhysicsClientHandle,
        bodyUniqueId: ::std::os::raw::c_int,
        linkIndex: ::std::os::raw::c_int,
        localPosition: *const f64,
        jointPositionsQ: *const f64,
        jointVelocitiesQdot: *const f64,
        jointAccelerations: *const f64,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3GetStatusJacobian(
        statusHandle: b3SharedMemoryStatusHandle,
        dofCount: *mut ::std::os::raw::c_int,
        linearJacobian: *mut f64,
        angularJacobian: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CalculateMassMatrixCommandInit(
        physClient: b3PhysicsClientHandle,
        bodyUniqueId: ::std::os::raw::c_int,
        jointPositionsQ: *const f64,
        dofCountQ: ::std::os::raw::c_int,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3CalculateMassMatrixSetFlags(
        commandHandle: b3SharedMemoryCommandHandle,
        flags: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = "the mass matrix is stored in column-major layout of size dofCount*dofCount"]
    pub fn b3GetStatusMassMatrix(
        physClient: b3PhysicsClientHandle,
        statusHandle: b3SharedMemoryStatusHandle,
        dofCount: *mut ::std::os::raw::c_int,
        massMatrix: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "compute the joint positions to move the end effector to a desired target using inverse kinematics"]
    pub fn b3CalculateInverseKinematicsCommandInit(
        physClient: b3PhysicsClientHandle,
        bodyUniqueId: ::std::os::raw::c_int,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3CalculateInverseKinematicsAddTargetPurePosition(
        commandHandle: b3SharedMemoryCommandHandle,
        endEffectorLinkIndex: ::std::os::raw::c_int,
        targetPosition: *const f64,
    );
}
extern "C" {
    pub fn b3CalculateInverseKinematicsAddTargetsPurePosition(
        commandHandle: b3SharedMemoryCommandHandle,
        numEndEffectorLinkIndices: ::std::os::raw::c_int,
        endEffectorIndices: *const ::std::os::raw::c_int,
        targetPositions: *const f64,
    );
}
extern "C" {
    pub fn b3CalculateInverseKinematicsAddTargetPositionWithOrientation(
        commandHandle: b3SharedMemoryCommandHandle,
        endEffectorLinkIndex: ::std::os::raw::c_int,
        targetPosition: *const f64,
        targetOrientation: *const f64,
    );
}
extern "C" {
    pub fn b3CalculateInverseKinematicsPosWithNullSpaceVel(
        commandHandle: b3SharedMemoryCommandHandle,
        numDof: ::std::os::raw::c_int,
        endEffectorLinkIndex: ::std::os::raw::c_int,
        targetPosition: *const f64,
        lowerLimit: *const f64,
        upperLimit: *const f64,
        jointRange: *const f64,
        restPose: *const f64,
    );
}
extern "C" {
    pub fn b3CalculateInverseKinematicsPosOrnWithNullSpaceVel(
        commandHandle: b3SharedMemoryCommandHandle,
        numDof: ::std::os::raw::c_int,
        endEffectorLinkIndex: ::std::os::raw::c_int,
        targetPosition: *const f64,
        targetOrientation: *const f64,
        lowerLimit: *const f64,
        upperLimit: *const f64,
        jointRange: *const f64,
        restPose: *const f64,
    );
}
extern "C" {
    pub fn b3CalculateInverseKinematicsSetJointDamping(
        commandHandle: b3SharedMemoryCommandHandle,
        numDof: ::std::os::raw::c_int,
        jointDampingCoeff: *const f64,
    );
}
extern "C" {
    pub fn b3CalculateInverseKinematicsSelectSolver(
        commandHandle: b3SharedMemoryCommandHandle,
        solver: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn b3GetStatusInverseKinematicsJointPositions(
        statusHandle: b3SharedMemoryStatusHandle,
        bodyUniqueId: *mut ::std::os::raw::c_int,
        dofCount: *mut ::std::os::raw::c_int,
        jointPositions: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CalculateInverseKinematicsSetCurrentPositions(
        commandHandle: b3SharedMemoryCommandHandle,
        numDof: ::std::os::raw::c_int,
        currentJointPositions: *const f64,
    );
}
extern "C" {
    pub fn b3CalculateInverseKinematicsSetMaxNumIterations(
        commandHandle: b3SharedMemoryCommandHandle,
        maxNumIterations: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn b3CalculateInverseKinematicsSetResidualThreshold(
        commandHandle: b3SharedMemoryCommandHandle,
        residualThreshold: f64,
    );
}
extern "C" {
    pub fn b3CollisionFilterCommandInit(
        physClient: b3PhysicsClientHandle,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3SetCollisionFilterPair(
        commandHandle: b3SharedMemoryCommandHandle,
        bodyUniqueIdA: ::std::os::raw::c_int,
        bodyUniqueIdB: ::std::os::raw::c_int,
        linkIndexA: ::std::os::raw::c_int,
        linkIndexB: ::std::os::raw::c_int,
        enableCollision: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn b3SetCollisionFilterGroupMask(
        commandHandle: b3SharedMemoryCommandHandle,
        bodyUniqueIdA: ::std::os::raw::c_int,
        linkIndexA: ::std::os::raw::c_int,
        collisionFilterGroup: ::std::os::raw::c_int,
        collisionFilterMask: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn b3LoadSdfCommandInit(
        physClient: b3PhysicsClientHandle,
        sdfFileName: *const ::std::os::raw::c_char,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3LoadSdfCommandInit2(
        commandHandle: b3SharedMemoryCommandHandle,
        sdfFileName: *const ::std::os::raw::c_char,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3LoadSdfCommandSetUseMultiBody(
        commandHandle: b3SharedMemoryCommandHandle,
        useMultiBody: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3LoadSdfCommandSetUseGlobalScaling(
        commandHandle: b3SharedMemoryCommandHandle,
        globalScaling: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3SaveWorldCommandInit(
        physClient: b3PhysicsClientHandle,
        sdfFileName: *const ::std::os::raw::c_char,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    #[doc = "The b3JointControlCommandInit method is obsolete, use b3JointControlCommandInit2 instead"]
    pub fn b3JointControlCommandInit(
        physClient: b3PhysicsClientHandle,
        controlMode: ::std::os::raw::c_int,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    #[doc = "Set joint motor control variables such as desired position/angle, desired velocity,\napplied joint forces, dependent on the control mode (CONTROL_MODE_VELOCITY or CONTROL_MODE_TORQUE)"]
    pub fn b3JointControlCommandInit2(
        physClient: b3PhysicsClientHandle,
        bodyUniqueId: ::std::os::raw::c_int,
        controlMode: ::std::os::raw::c_int,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3JointControlCommandInit2Internal(
        commandHandle: b3SharedMemoryCommandHandle,
        bodyUniqueId: ::std::os::raw::c_int,
        controlMode: ::std::os::raw::c_int,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    #[doc = "Only use when controlMode is CONTROL_MODE_POSITION_VELOCITY_PD"]
    pub fn b3JointControlSetDesiredPosition(
        commandHandle: b3SharedMemoryCommandHandle,
        qIndex: ::std::os::raw::c_int,
        value: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3JointControlSetDesiredPositionMultiDof(
        commandHandle: b3SharedMemoryCommandHandle,
        qIndex: ::std::os::raw::c_int,
        position: *const f64,
        dofCount: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3JointControlSetKp(
        commandHandle: b3SharedMemoryCommandHandle,
        dofIndex: ::std::os::raw::c_int,
        value: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3JointControlSetKpMultiDof(
        commandHandle: b3SharedMemoryCommandHandle,
        dofIndex: ::std::os::raw::c_int,
        kps: *mut f64,
        dofCount: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3JointControlSetKd(
        commandHandle: b3SharedMemoryCommandHandle,
        dofIndex: ::std::os::raw::c_int,
        value: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3JointControlSetKdMultiDof(
        commandHandle: b3SharedMemoryCommandHandle,
        dofIndex: ::std::os::raw::c_int,
        kds: *mut f64,
        dofCount: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3JointControlSetMaximumVelocity(
        commandHandle: b3SharedMemoryCommandHandle,
        dofIndex: ::std::os::raw::c_int,
        maximumVelocity: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Only use when controlMode is CONTROL_MODE_VELOCITY"]
    pub fn b3JointControlSetDesiredVelocity(
        commandHandle: b3SharedMemoryCommandHandle,
        dofIndex: ::std::os::raw::c_int,
        value: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3JointControlSetDesiredVelocityMultiDof(
        commandHandle: b3SharedMemoryCommandHandle,
        dofIndex: ::std::os::raw::c_int,
        velocity: *const f64,
        dofCount: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3JointControlSetDesiredVelocityMultiDof2(
        commandHandle: b3SharedMemoryCommandHandle,
        dofIndex: ::std::os::raw::c_int,
        velocity: *const f64,
        dofCount: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3JointControlSetMaximumForce(
        commandHandle: b3SharedMemoryCommandHandle,
        dofIndex: ::std::os::raw::c_int,
        value: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3JointControlSetDesiredForceTorqueMultiDof(
        commandHandle: b3SharedMemoryCommandHandle,
        dofIndex: ::std::os::raw::c_int,
        forces: *mut f64,
        dofCount: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3JointControlSetDamping(
        commandHandle: b3SharedMemoryCommandHandle,
        dofIndex: ::std::os::raw::c_int,
        value: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3JointControlSetDampingMultiDof(
        commandHandle: b3SharedMemoryCommandHandle,
        dofIndex: ::std::os::raw::c_int,
        damping: *mut f64,
        dofCount: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Only use if when controlMode is CONTROL_MODE_TORQUE,"]
    pub fn b3JointControlSetDesiredForceTorque(
        commandHandle: b3SharedMemoryCommandHandle,
        dofIndex: ::std::os::raw::c_int,
        value: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "the creation of collision shapes and rigid bodies etc is likely going to change,\nbut good to have a b3CreateBoxShapeCommandInit for now"]
    pub fn b3CreateCollisionShapeCommandInit(
        physClient: b3PhysicsClientHandle,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3CreateCollisionShapeAddSphere(
        commandHandle: b3SharedMemoryCommandHandle,
        radius: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CreateCollisionShapeAddBox(
        commandHandle: b3SharedMemoryCommandHandle,
        halfExtents: *const f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CreateCollisionShapeAddCapsule(
        commandHandle: b3SharedMemoryCommandHandle,
        radius: f64,
        height: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CreateCollisionShapeAddCylinder(
        commandHandle: b3SharedMemoryCommandHandle,
        radius: f64,
        height: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CreateCollisionShapeAddHeightfield(
        commandHandle: b3SharedMemoryCommandHandle,
        fileName: *const ::std::os::raw::c_char,
        meshScale: *const f64,
        textureScaling: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CreateCollisionShapeAddHeightfield2(
        physClient: b3PhysicsClientHandle,
        commandHandle: b3SharedMemoryCommandHandle,
        meshScale: *const f64,
        textureScaling: f64,
        heightfieldData: *mut f32,
        numHeightfieldRows: ::std::os::raw::c_int,
        numHeightfieldColumns: ::std::os::raw::c_int,
        replaceHeightfieldIndex: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CreateCollisionShapeAddPlane(
        commandHandle: b3SharedMemoryCommandHandle,
        planeNormal: *const f64,
        planeConstant: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CreateCollisionShapeAddMesh(
        commandHandle: b3SharedMemoryCommandHandle,
        fileName: *const ::std::os::raw::c_char,
        meshScale: *const f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CreateCollisionShapeAddConvexMesh(
        physClient: b3PhysicsClientHandle,
        commandHandle: b3SharedMemoryCommandHandle,
        meshScale: *const f64,
        vertices: *const f64,
        numVertices: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CreateCollisionShapeAddConcaveMesh(
        physClient: b3PhysicsClientHandle,
        commandHandle: b3SharedMemoryCommandHandle,
        meshScale: *const f64,
        vertices: *const f64,
        numVertices: ::std::os::raw::c_int,
        indices: *const ::std::os::raw::c_int,
        numIndices: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CreateCollisionSetFlag(
        commandHandle: b3SharedMemoryCommandHandle,
        shapeIndex: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn b3CreateCollisionShapeSetChildTransform(
        commandHandle: b3SharedMemoryCommandHandle,
        shapeIndex: ::std::os::raw::c_int,
        childPosition: *const f64,
        childOrientation: *const f64,
    );
}
extern "C" {
    pub fn b3GetStatusCollisionShapeUniqueId(
        statusHandle: b3SharedMemoryStatusHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3InitRemoveCollisionShapeCommand(
        physClient: b3PhysicsClientHandle,
        collisionShapeId: ::std::os::raw::c_int,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3GetMeshDataCommandInit(
        physClient: b3PhysicsClientHandle,
        bodyUniqueId: ::std::os::raw::c_int,
        linkIndex: ::std::os::raw::c_int,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3GetTetraMeshDataCommandInit(
        physClient: b3PhysicsClientHandle,
        bodyUniqueId: ::std::os::raw::c_int,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3GetMeshDataSimulationMesh(commandHandle: b3SharedMemoryCommandHandle);
}
extern "C" {
    pub fn b3MeshDataSimulationMeshVelocity(commandHandle: b3SharedMemoryCommandHandle);
}
extern "C" {
    pub fn b3GetMeshDataSetCollisionShapeIndex(
        commandHandle: b3SharedMemoryCommandHandle,
        shapeIndex: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn b3GetMeshDataSetFlags(
        commandHandle: b3SharedMemoryCommandHandle,
        flags: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn b3GetTetraMeshDataSetFlags(
        commandHandle: b3SharedMemoryCommandHandle,
        flags: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn b3GetMeshData(physClient: b3PhysicsClientHandle, meshData: *mut b3MeshData);
}
extern "C" {
    pub fn b3GetTetraMeshData(physClient: b3PhysicsClientHandle, meshData: *mut b3TetraMeshData);
}
extern "C" {
    pub fn b3ResetMeshDataCommandInit(
        physClient: b3PhysicsClientHandle,
        bodyUniqueId: ::std::os::raw::c_int,
        num_vertices: ::std::os::raw::c_int,
        vertices: *const f64,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3CreateVisualShapeCommandInit(
        physClient: b3PhysicsClientHandle,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3CreateVisualShapeAddSphere(
        commandHandle: b3SharedMemoryCommandHandle,
        radius: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CreateVisualShapeAddBox(
        commandHandle: b3SharedMemoryCommandHandle,
        halfExtents: *const f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CreateVisualShapeAddCapsule(
        commandHandle: b3SharedMemoryCommandHandle,
        radius: f64,
        height: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CreateVisualShapeAddCylinder(
        commandHandle: b3SharedMemoryCommandHandle,
        radius: f64,
        height: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CreateVisualShapeAddPlane(
        commandHandle: b3SharedMemoryCommandHandle,
        planeNormal: *const f64,
        planeConstant: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CreateVisualShapeAddMesh(
        commandHandle: b3SharedMemoryCommandHandle,
        fileName: *const ::std::os::raw::c_char,
        meshScale: *const f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CreateVisualShapeAddMesh2(
        physClient: b3PhysicsClientHandle,
        commandHandle: b3SharedMemoryCommandHandle,
        meshScale: *const f64,
        vertices: *const f64,
        numVertices: ::std::os::raw::c_int,
        indices: *const ::std::os::raw::c_int,
        numIndices: ::std::os::raw::c_int,
        normals: *const f64,
        numNormals: ::std::os::raw::c_int,
        uvs: *const f64,
        numUVs: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CreateVisualSetFlag(
        commandHandle: b3SharedMemoryCommandHandle,
        shapeIndex: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn b3CreateVisualShapeSetChildTransform(
        commandHandle: b3SharedMemoryCommandHandle,
        shapeIndex: ::std::os::raw::c_int,
        childPosition: *const f64,
        childOrientation: *const f64,
    );
}
extern "C" {
    pub fn b3CreateVisualShapeSetSpecularColor(
        commandHandle: b3SharedMemoryCommandHandle,
        shapeIndex: ::std::os::raw::c_int,
        specularColor: *const f64,
    );
}
extern "C" {
    pub fn b3CreateVisualShapeSetRGBAColor(
        commandHandle: b3SharedMemoryCommandHandle,
        shapeIndex: ::std::os::raw::c_int,
        rgbaColor: *const f64,
    );
}
extern "C" {
    pub fn b3GetStatusVisualShapeUniqueId(
        statusHandle: b3SharedMemoryStatusHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CreateMultiBodyCommandInit(
        physClient: b3PhysicsClientHandle,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3CreateMultiBodyBase(
        commandHandle: b3SharedMemoryCommandHandle,
        mass: f64,
        collisionShapeUnique: ::std::os::raw::c_int,
        visualShapeUniqueId: ::std::os::raw::c_int,
        basePosition: *const f64,
        baseOrientation: *const f64,
        baseInertialFramePosition: *const f64,
        baseInertialFrameOrientation: *const f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CreateMultiBodyLink(
        commandHandle: b3SharedMemoryCommandHandle,
        linkMass: f64,
        linkCollisionShapeIndex: f64,
        linkVisualShapeIndex: f64,
        linkPosition: *const f64,
        linkOrientation: *const f64,
        linkInertialFramePosition: *const f64,
        linkInertialFrameOrientation: *const f64,
        linkParentIndex: ::std::os::raw::c_int,
        linkJointType: ::std::os::raw::c_int,
        linkJointAxis: *const f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CreateMultiBodySetBatchPositions(
        physClient: b3PhysicsClientHandle,
        commandHandle: b3SharedMemoryCommandHandle,
        batchPositions: *mut f64,
        numBatchObjects: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CreateMultiBodyUseMaximalCoordinates(commandHandle: b3SharedMemoryCommandHandle);
}
extern "C" {
    pub fn b3CreateMultiBodySetFlags(
        commandHandle: b3SharedMemoryCommandHandle,
        flags: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = "create a box of size (1,1,1) at world origin (0,0,0) at orientation quat (0,0,0,1)\nafter that, you can optionally adjust the initial position, orientation and size"]
    pub fn b3CreateBoxShapeCommandInit(
        physClient: b3PhysicsClientHandle,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3CreateBoxCommandSetStartPosition(
        commandHandle: b3SharedMemoryCommandHandle,
        startPosX: f64,
        startPosY: f64,
        startPosZ: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CreateBoxCommandSetStartOrientation(
        commandHandle: b3SharedMemoryCommandHandle,
        startOrnX: f64,
        startOrnY: f64,
        startOrnZ: f64,
        startOrnW: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CreateBoxCommandSetHalfExtents(
        commandHandle: b3SharedMemoryCommandHandle,
        halfExtentsX: f64,
        halfExtentsY: f64,
        halfExtentsZ: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CreateBoxCommandSetMass(
        commandHandle: b3SharedMemoryCommandHandle,
        mass: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CreateBoxCommandSetCollisionShapeType(
        commandHandle: b3SharedMemoryCommandHandle,
        collisionShapeType: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CreateBoxCommandSetColorRGBA(
        commandHandle: b3SharedMemoryCommandHandle,
        red: f64,
        green: f64,
        blue: f64,
        alpha: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "b3CreatePoseCommandInit will initialize (teleport) the pose of a body/robot. You can individually set the base position,\nbase orientation and joint angles. This will set all velocities of base and joints to zero.\nThis is not a robot control command using actuators/joint motors, but manual repositioning the robot."]
    pub fn b3CreatePoseCommandInit(
        physClient: b3PhysicsClientHandle,
        bodyUniqueId: ::std::os::raw::c_int,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3CreatePoseCommandInit2(
        commandHandle: b3SharedMemoryCommandHandle,
        bodyUniqueId: ::std::os::raw::c_int,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3CreatePoseCommandSetBasePosition(
        commandHandle: b3SharedMemoryCommandHandle,
        startPosX: f64,
        startPosY: f64,
        startPosZ: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CreatePoseCommandSetBaseOrientation(
        commandHandle: b3SharedMemoryCommandHandle,
        startOrnX: f64,
        startOrnY: f64,
        startOrnZ: f64,
        startOrnW: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CreatePoseCommandSetBaseLinearVelocity(
        commandHandle: b3SharedMemoryCommandHandle,
        linVel: *const f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CreatePoseCommandSetBaseAngularVelocity(
        commandHandle: b3SharedMemoryCommandHandle,
        angVel: *const f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CreatePoseCommandSetBaseScaling(
        commandHandle: b3SharedMemoryCommandHandle,
        scaling: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CreatePoseCommandSetJointPositions(
        commandHandle: b3SharedMemoryCommandHandle,
        numJointPositions: ::std::os::raw::c_int,
        jointPositions: *const f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CreatePoseCommandSetJointPosition(
        physClient: b3PhysicsClientHandle,
        commandHandle: b3SharedMemoryCommandHandle,
        jointIndex: ::std::os::raw::c_int,
        jointPosition: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CreatePoseCommandSetJointPositionMultiDof(
        physClient: b3PhysicsClientHandle,
        commandHandle: b3SharedMemoryCommandHandle,
        jointIndex: ::std::os::raw::c_int,
        jointPosition: *const f64,
        posSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CreatePoseCommandSetQ(
        commandHandle: b3SharedMemoryCommandHandle,
        numJointPositions: ::std::os::raw::c_int,
        q: *const f64,
        hasQ: *const ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CreatePoseCommandSetQdots(
        commandHandle: b3SharedMemoryCommandHandle,
        numJointVelocities: ::std::os::raw::c_int,
        qDots: *const f64,
        hasQdots: *const ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CreatePoseCommandSetJointVelocities(
        physClient: b3PhysicsClientHandle,
        commandHandle: b3SharedMemoryCommandHandle,
        numJointVelocities: ::std::os::raw::c_int,
        jointVelocities: *const f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CreatePoseCommandSetJointVelocity(
        physClient: b3PhysicsClientHandle,
        commandHandle: b3SharedMemoryCommandHandle,
        jointIndex: ::std::os::raw::c_int,
        jointVelocity: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3CreatePoseCommandSetJointVelocityMultiDof(
        physClient: b3PhysicsClientHandle,
        commandHandle: b3SharedMemoryCommandHandle,
        jointIndex: ::std::os::raw::c_int,
        jointVelocity: *const f64,
        velSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "We are currently not reading the sensor information from the URDF file, and programmatically assign sensors.\nThis is rather inconsistent, to mix programmatical creation with loading from file."]
    pub fn b3CreateSensorCommandInit(
        physClient: b3PhysicsClientHandle,
        bodyUniqueId: ::std::os::raw::c_int,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3CreateSensorEnable6DofJointForceTorqueSensor(
        commandHandle: b3SharedMemoryCommandHandle,
        jointIndex: ::std::os::raw::c_int,
        enable: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "b3CreateSensorEnableIMUForLink is not implemented yet.\nFor now, if the IMU is located in the root link, use the root world transform to mimic an IMU."]
    pub fn b3CreateSensorEnableIMUForLink(
        commandHandle: b3SharedMemoryCommandHandle,
        linkIndex: ::std::os::raw::c_int,
        enable: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3RequestActualStateCommandInit(
        physClient: b3PhysicsClientHandle,
        bodyUniqueId: ::std::os::raw::c_int,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3RequestActualStateCommandInit2(
        commandHandle: b3SharedMemoryCommandHandle,
        bodyUniqueId: ::std::os::raw::c_int,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3RequestActualStateCommandComputeLinkVelocity(
        commandHandle: b3SharedMemoryCommandHandle,
        computeLinkVelocity: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3RequestActualStateCommandComputeForwardKinematics(
        commandHandle: b3SharedMemoryCommandHandle,
        computeForwardKinematics: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3GetJointState(
        physClient: b3PhysicsClientHandle,
        statusHandle: b3SharedMemoryStatusHandle,
        jointIndex: ::std::os::raw::c_int,
        state: *mut b3JointSensorState,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3GetJointStateMultiDof(
        physClient: b3PhysicsClientHandle,
        statusHandle: b3SharedMemoryStatusHandle,
        jointIndex: ::std::os::raw::c_int,
        state: *mut b3JointSensorState2,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3GetLinkState(
        physClient: b3PhysicsClientHandle,
        statusHandle: b3SharedMemoryStatusHandle,
        linkIndex: ::std::os::raw::c_int,
        state: *mut b3LinkState,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3PickBody(
        physClient: b3PhysicsClientHandle,
        rayFromWorldX: f64,
        rayFromWorldY: f64,
        rayFromWorldZ: f64,
        rayToWorldX: f64,
        rayToWorldY: f64,
        rayToWorldZ: f64,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3MovePickedBody(
        physClient: b3PhysicsClientHandle,
        rayFromWorldX: f64,
        rayFromWorldY: f64,
        rayFromWorldZ: f64,
        rayToWorldX: f64,
        rayToWorldY: f64,
        rayToWorldZ: f64,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3RemovePickingConstraint(
        physClient: b3PhysicsClientHandle,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3CreateRaycastCommandInit(
        physClient: b3PhysicsClientHandle,
        rayFromWorldX: f64,
        rayFromWorldY: f64,
        rayFromWorldZ: f64,
        rayToWorldX: f64,
        rayToWorldY: f64,
        rayToWorldZ: f64,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3CreateRaycastBatchCommandInit(
        physClient: b3PhysicsClientHandle,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3RaycastBatchSetNumThreads(
        commandHandle: b3SharedMemoryCommandHandle,
        numThreads: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn b3RaycastBatchAddRay(
        commandHandle: b3SharedMemoryCommandHandle,
        rayFromWorld: *const f64,
        rayToWorld: *const f64,
    );
}
extern "C" {
    pub fn b3RaycastBatchAddRays(
        physClient: b3PhysicsClientHandle,
        commandHandle: b3SharedMemoryCommandHandle,
        rayFromWorld: *const f64,
        rayToWorld: *const f64,
        numRays: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn b3RaycastBatchSetParentObject(
        commandHandle: b3SharedMemoryCommandHandle,
        parentObjectUniqueId: ::std::os::raw::c_int,
        parentLinkIndex: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn b3RaycastBatchSetReportHitNumber(
        commandHandle: b3SharedMemoryCommandHandle,
        reportHitNumber: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn b3RaycastBatchSetCollisionFilterMask(
        commandHandle: b3SharedMemoryCommandHandle,
        collisionFilterMask: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn b3RaycastBatchSetFractionEpsilon(
        commandHandle: b3SharedMemoryCommandHandle,
        fractionEpsilon: f64,
    );
}
extern "C" {
    pub fn b3GetRaycastInformation(
        physClient: b3PhysicsClientHandle,
        raycastInfo: *mut b3RaycastInformation,
    );
}
extern "C" {
    #[doc = " Apply external force at the body (or link) center of mass, in world space/Cartesian coordinates."]
    pub fn b3ApplyExternalForceCommandInit(
        physClient: b3PhysicsClientHandle,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3ApplyExternalForce(
        commandHandle: b3SharedMemoryCommandHandle,
        bodyUniqueId: ::std::os::raw::c_int,
        linkId: ::std::os::raw::c_int,
        force: *const f64,
        position: *const f64,
        flag: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn b3ApplyExternalTorque(
        commandHandle: b3SharedMemoryCommandHandle,
        bodyUniqueId: ::std::os::raw::c_int,
        linkId: ::std::os::raw::c_int,
        torque: *const f64,
        flag: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = "experiments of robots interacting with non-rigid objects (such as btSoftBody)"]
    pub fn b3LoadSoftBodyCommandInit(
        physClient: b3PhysicsClientHandle,
        fileName: *const ::std::os::raw::c_char,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3LoadSoftBodySetScale(
        commandHandle: b3SharedMemoryCommandHandle,
        scale: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3LoadSoftBodySetMass(
        commandHandle: b3SharedMemoryCommandHandle,
        mass: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3LoadSoftBodySetCollisionMargin(
        commandHandle: b3SharedMemoryCommandHandle,
        collisionMargin: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3LoadSoftBodySetStartPosition(
        commandHandle: b3SharedMemoryCommandHandle,
        startPosX: f64,
        startPosY: f64,
        startPosZ: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3LoadSoftBodySetStartOrientation(
        commandHandle: b3SharedMemoryCommandHandle,
        startOrnX: f64,
        startOrnY: f64,
        startOrnZ: f64,
        startOrnW: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3LoadSoftBodyUpdateSimMesh(
        commandHandle: b3SharedMemoryCommandHandle,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3LoadSoftBodyAddCorotatedForce(
        commandHandle: b3SharedMemoryCommandHandle,
        corotatedMu: f64,
        corotatedLambda: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3LoadSoftBodyAddNeoHookeanForce(
        commandHandle: b3SharedMemoryCommandHandle,
        NeoHookeanMu: f64,
        NeoHookeanLambda: f64,
        NeoHookeanDamping: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3LoadSoftBodyAddMassSpringForce(
        commandHandle: b3SharedMemoryCommandHandle,
        springElasticStiffness: f64,
        springDampingStiffness: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3LoadSoftBodyAddGravityForce(
        commandHandle: b3SharedMemoryCommandHandle,
        gravityX: f64,
        gravityY: f64,
        gravityZ: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3LoadSoftBodySetCollisionHardness(
        commandHandle: b3SharedMemoryCommandHandle,
        collisionHardness: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3LoadSoftBodySetSelfCollision(
        commandHandle: b3SharedMemoryCommandHandle,
        useSelfCollision: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3LoadSoftBodySetRepulsionStiffness(
        commandHandle: b3SharedMemoryCommandHandle,
        stiffness: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3LoadSoftBodyUseFaceContact(
        commandHandle: b3SharedMemoryCommandHandle,
        useFaceContact: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3LoadSoftBodySetFrictionCoefficient(
        commandHandle: b3SharedMemoryCommandHandle,
        frictionCoefficient: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3LoadSoftBodyUseBendingSprings(
        commandHandle: b3SharedMemoryCommandHandle,
        useBendingSprings: ::std::os::raw::c_int,
        bendingStiffness: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3LoadSoftBodyUseAllDirectionDampingSprings(
        commandHandle: b3SharedMemoryCommandHandle,
        useAllDirectionDamping: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3InitCreateSoftBodyAnchorConstraintCommand(
        physClient: b3PhysicsClientHandle,
        softBodyUniqueId: ::std::os::raw::c_int,
        nodeIndex: ::std::os::raw::c_int,
        bodyUniqueId: ::std::os::raw::c_int,
        linkIndex: ::std::os::raw::c_int,
        bodyFramePosition: *const f64,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3RequestVREventsCommandInit(
        physClient: b3PhysicsClientHandle,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3VREventsSetDeviceTypeFilter(
        commandHandle: b3SharedMemoryCommandHandle,
        deviceTypeFilter: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn b3GetVREventsData(physClient: b3PhysicsClientHandle, vrEventsData: *mut b3VREventsData);
}
extern "C" {
    pub fn b3SetVRCameraStateCommandInit(
        physClient: b3PhysicsClientHandle,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3SetVRCameraRootPosition(
        commandHandle: b3SharedMemoryCommandHandle,
        rootPos: *const f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3SetVRCameraRootOrientation(
        commandHandle: b3SharedMemoryCommandHandle,
        rootOrn: *const f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3SetVRCameraTrackingObject(
        commandHandle: b3SharedMemoryCommandHandle,
        objectUniqueId: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3SetVRCameraTrackingObjectFlag(
        commandHandle: b3SharedMemoryCommandHandle,
        flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3RequestKeyboardEventsCommandInit(
        physClient: b3PhysicsClientHandle,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3RequestKeyboardEventsCommandInit2(
        commandHandle: b3SharedMemoryCommandHandle,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3GetKeyboardEventsData(
        physClient: b3PhysicsClientHandle,
        keyboardEventsData: *mut b3KeyboardEventsData,
    );
}
extern "C" {
    pub fn b3RequestMouseEventsCommandInit(
        physClient: b3PhysicsClientHandle,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3GetMouseEventsData(
        physClient: b3PhysicsClientHandle,
        mouseEventsData: *mut b3MouseEventsData,
    );
}
extern "C" {
    pub fn b3StateLoggingCommandInit(
        physClient: b3PhysicsClientHandle,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3StateLoggingStart(
        commandHandle: b3SharedMemoryCommandHandle,
        loggingType: ::std::os::raw::c_int,
        fileName: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3StateLoggingAddLoggingObjectUniqueId(
        commandHandle: b3SharedMemoryCommandHandle,
        objectUniqueId: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3StateLoggingSetMaxLogDof(
        commandHandle: b3SharedMemoryCommandHandle,
        maxLogDof: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3StateLoggingSetLinkIndexA(
        commandHandle: b3SharedMemoryCommandHandle,
        linkIndexA: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3StateLoggingSetLinkIndexB(
        commandHandle: b3SharedMemoryCommandHandle,
        linkIndexB: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3StateLoggingSetBodyAUniqueId(
        commandHandle: b3SharedMemoryCommandHandle,
        bodyAUniqueId: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3StateLoggingSetBodyBUniqueId(
        commandHandle: b3SharedMemoryCommandHandle,
        bodyBUniqueId: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3StateLoggingSetDeviceTypeFilter(
        commandHandle: b3SharedMemoryCommandHandle,
        deviceTypeFilter: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3StateLoggingSetLogFlags(
        commandHandle: b3SharedMemoryCommandHandle,
        logFlags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3GetStatusLoggingUniqueId(
        statusHandle: b3SharedMemoryStatusHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3StateLoggingStop(
        commandHandle: b3SharedMemoryCommandHandle,
        loggingUid: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b3ProfileTimingCommandInit(
        physClient: b3PhysicsClientHandle,
        name: *const ::std::os::raw::c_char,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3SetProfileTimingDuractionInMicroSeconds(
        commandHandle: b3SharedMemoryCommandHandle,
        duration: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn b3SetProfileTimingType(
        commandHandle: b3SharedMemoryCommandHandle,
        type_: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn b3PushProfileTiming(
        physClient: b3PhysicsClientHandle,
        timingName: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn b3PopProfileTiming(physClient: b3PhysicsClientHandle);
}
extern "C" {
    pub fn b3SetTimeOut(physClient: b3PhysicsClientHandle, timeOutInSeconds: f64);
}
extern "C" {
    pub fn b3GetTimeOut(physClient: b3PhysicsClientHandle) -> f64;
}
extern "C" {
    pub fn b3SetAdditionalSearchPath(
        physClient: b3PhysicsClientHandle,
        path: *const ::std::os::raw::c_char,
    ) -> b3SharedMemoryCommandHandle;
}
extern "C" {
    pub fn b3MultiplyTransforms(
        posA: *const f64,
        ornA: *const f64,
        posB: *const f64,
        ornB: *const f64,
        outPos: *mut f64,
        outOrn: *mut f64,
    );
}
extern "C" {
    pub fn b3InvertTransform(pos: *const f64, orn: *const f64, outPos: *mut f64, outOrn: *mut f64);
}
extern "C" {
    pub fn b3QuaternionSlerp(
        startQuat: *const f64,
        endQuat: *const f64,
        interpolationFraction: f64,
        outOrn: *mut f64,
    );
}
extern "C" {
    pub fn b3GetQuaternionFromAxisAngle(axis: *const f64, angle: f64, outQuat: *mut f64);
}
extern "C" {
    pub fn b3GetAxisAngleFromQuaternion(quat: *const f64, axis: *mut f64, angle: *mut f64);
}
extern "C" {
    pub fn b3GetQuaternionDifference(startQuat: *const f64, endQuat: *const f64, outOrn: *mut f64);
}
extern "C" {
    pub fn b3GetAxisDifferenceQuaternion(
        startQuat: *const f64,
        endQuat: *const f64,
        axisOut: *mut f64,
    );
}
extern "C" {
    pub fn b3CalculateVelocityQuaternion(
        startQuat: *const f64,
        endQuat: *const f64,
        deltaTime: f64,
        angVelOut: *mut f64,
    );
}
extern "C" {
    pub fn b3RotateVector(quat: *const f64, vec: *const f64, vecOut: *mut f64);
}
