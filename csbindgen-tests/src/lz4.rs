/* automatically generated by rust-bindgen 0.64.0 */

pub const LZ4_FREESTANDING: u32 = 0;
pub const LZ4_VERSION_MAJOR: u32 = 1;
pub const LZ4_VERSION_MINOR: u32 = 9;
pub const LZ4_VERSION_RELEASE: u32 = 4;
pub const LZ4_VERSION_NUMBER: u32 = 10904;
pub const LZ4_MEMORY_USAGE_MIN: u32 = 10;
pub const LZ4_MEMORY_USAGE_DEFAULT: u32 = 14;
pub const LZ4_MEMORY_USAGE_MAX: u32 = 20;
pub const LZ4_MEMORY_USAGE: u32 = 14;
pub const LZ4_MAX_INPUT_SIZE: u32 = 2113929216;
pub const LZ4_HASHLOG: u32 = 12;
pub const LZ4_HASHTABLESIZE: u32 = 16384;
pub const LZ4_HASH_SIZE_U32: u32 = 4096;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 35;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const LZ4_STREAM_MINSIZE: u32 = 16416;
pub const LZ4_STREAMDECODE_MINSIZE: u32 = 32;
pub const LZ4HC_CLEVEL_MIN: u32 = 3;
pub const LZ4HC_CLEVEL_DEFAULT: u32 = 9;
pub const LZ4HC_CLEVEL_OPT_MIN: u32 = 10;
pub const LZ4HC_CLEVEL_MAX: u32 = 12;
pub const LZ4HC_DICTIONARY_LOGSIZE: u32 = 16;
pub const LZ4HC_MAXD: u32 = 65536;
pub const LZ4HC_MAXD_MASK: u32 = 65535;
pub const LZ4HC_HASH_LOG: u32 = 15;
pub const LZ4HC_HASHTABLESIZE: u32 = 32768;
pub const LZ4HC_HASH_MASK: u32 = 32767;
pub const LZ4_STREAMHC_MINSIZE: u32 = 262200;
pub const LZ4F_VERSION: u32 = 100;
pub const LZ4F_HEADER_SIZE_MIN: u32 = 7;
pub const LZ4F_HEADER_SIZE_MAX: u32 = 19;
pub const LZ4F_BLOCK_HEADER_SIZE: u32 = 4;
pub const LZ4F_BLOCK_CHECKSUM_SIZE: u32 = 4;
pub const LZ4F_CONTENT_CHECKSUM_SIZE: u32 = 4;
pub const LZ4F_MAGICNUMBER: u32 = 407708164;
pub const LZ4F_MAGIC_SKIPPABLE_START: u32 = 407710288;
pub const LZ4F_MIN_SIZE_TO_KNOW_HEADER_LENGTH: u32 = 5;
pub const XXHASH_H_5627135585666179: u32 = 1;
pub const XXH_VERSION_MAJOR: u32 = 0;
pub const XXH_VERSION_MINOR: u32 = 6;
pub const XXH_VERSION_RELEASE: u32 = 5;
pub const XXH_VERSION_NUMBER: u32 = 605;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::std::mem::MaybeUninit<max_align_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
extern "C" {
    pub fn LZ4_versionNumber() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_versionString() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " LZ4_compress_default() :\n  Compresses 'srcSize' bytes from buffer 'src'\n  into already allocated 'dst' buffer of size 'dstCapacity'.\n  Compression is guaranteed to succeed if 'dstCapacity' >= LZ4_compressBound(srcSize).\n  It also runs faster, so it's a recommended setting.\n  If the function cannot compress 'src' into a more limited 'dst' budget,\n  compression stops *immediately*, and the function result is zero.\n  In which case, 'dst' content is undefined (invalid).\n      srcSize : max supported value is LZ4_MAX_INPUT_SIZE.\n      dstCapacity : size of buffer 'dst' (which must be already allocated)\n     @return  : the number of bytes written into buffer 'dst' (necessarily <= dstCapacity)\n                or 0 if compression fails\n Note : This function is protected against buffer overflow scenarios (never writes outside 'dst' buffer, nor read outside 'source' buffer)."]
    pub fn LZ4_compress_default(
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        srcSize: ::std::os::raw::c_int,
        dstCapacity: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_decompress_safe() :\n @compressedSize : is the exact complete size of the compressed block.\n @dstCapacity : is the size of destination buffer (which must be already allocated),\n                is an upper bound of decompressed size.\n @return : the number of bytes decompressed into destination buffer (necessarily <= dstCapacity)\n           If destination buffer is not large enough, decoding will stop and output an error code (negative value).\n           If the source stream is detected malformed, the function will stop decoding and return a negative result.\n Note 1 : This function is protected against malicious data packets :\n          it will never writes outside 'dst' buffer, nor read outside 'source' buffer,\n          even if the compressed block is maliciously modified to order the decoder to do these actions.\n          In such case, the decoder stops immediately, and considers the compressed block malformed.\n Note 2 : compressedSize and dstCapacity must be provided to the function, the compressed block does not contain them.\n          The implementation is free to send / store / derive this information in whichever way is most beneficial.\n          If there is a need for a different format which bundles together both compressed data and its metadata, consider looking at lz4frame.h instead."]
    pub fn LZ4_decompress_safe(
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        compressedSize: ::std::os::raw::c_int,
        dstCapacity: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_compressBound() :\nProvides the maximum size that LZ4 compression may output in a \"worst case\" scenario (input data not compressible)\nThis function is primarily useful for memory allocation purposes (destination buffer size).\nMacro LZ4_COMPRESSBOUND() is also provided for compilation-time evaluation (stack memory allocation for example).\nNote that LZ4_compress_default() compresses faster when dstCapacity is >= LZ4_compressBound(srcSize)\ninputSize  : max supported value is LZ4_MAX_INPUT_SIZE\nreturn : maximum output size in a \"worst case\" scenario\nor 0, if input size is incorrect (too large or negative)"]
    pub fn LZ4_compressBound(inputSize: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_compress_fast() :\nSame as LZ4_compress_default(), but allows selection of \"acceleration\" factor.\nThe larger the acceleration value, the faster the algorithm, but also the lesser the compression.\nIt's a trade-off. It can be fine tuned, with each successive value providing roughly +~3% to speed.\nAn acceleration value of \"1\" is the same as regular LZ4_compress_default()\nValues <= 0 will be replaced by LZ4_ACCELERATION_DEFAULT (currently == 1, see lz4.c).\nValues > LZ4_ACCELERATION_MAX will be replaced by LZ4_ACCELERATION_MAX (currently == 65537, see lz4.c)."]
    pub fn LZ4_compress_fast(
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        srcSize: ::std::os::raw::c_int,
        dstCapacity: ::std::os::raw::c_int,
        acceleration: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_compress_fast_extState() :\n  Same as LZ4_compress_fast(), using an externally allocated memory space for its state.\n  Use LZ4_sizeofState() to know how much memory must be allocated,\n  and allocate it on 8-bytes boundaries (using `malloc()` typically).\n  Then, provide this buffer as `void* state` to compression function."]
    pub fn LZ4_sizeofState() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_compress_fast_extState(
        state: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        srcSize: ::std::os::raw::c_int,
        dstCapacity: ::std::os::raw::c_int,
        acceleration: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_compress_destSize() :\n  Reverse the logic : compresses as much data as possible from 'src' buffer\n  into already allocated buffer 'dst', of size >= 'targetDestSize'.\n  This function either compresses the entire 'src' content into 'dst' if it's large enough,\n  or fill 'dst' buffer completely with as much data as possible from 'src'.\n  note: acceleration parameter is fixed to \"default\".\n\n *srcSizePtr : will be modified to indicate how many bytes where read from 'src' to fill 'dst'.\n               New value is necessarily <= input value.\n @return : Nb bytes written into 'dst' (necessarily <= targetDestSize)\n           or 0 if compression fails.\n\n Note : from v1.8.2 to v1.9.1, this function had a bug (fixed un v1.9.2+):\n        the produced compressed content could, in specific circumstances,\n        require to be decompressed into a destination buffer larger\n        by at least 1 byte than the content to decompress.\n        If an application uses `LZ4_compress_destSize()`,\n        it's highly recommended to update liblz4 to v1.9.2 or better.\n        If this can't be done or ensured,\n        the receiving decompression function should provide\n        a dstCapacity which is > decompressedSize, by at least 1 byte.\n        See https://github.com/lz4/lz4/issues/859 for details"]
    pub fn LZ4_compress_destSize(
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        srcSizePtr: *mut ::std::os::raw::c_int,
        targetDstSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_decompress_safe_partial() :\n  Decompress an LZ4 compressed block, of size 'srcSize' at position 'src',\n  into destination buffer 'dst' of size 'dstCapacity'.\n  Up to 'targetOutputSize' bytes will be decoded.\n  The function stops decoding on reaching this objective.\n  This can be useful to boost performance\n  whenever only the beginning of a block is required.\n\n @return : the number of bytes decoded in `dst` (necessarily <= targetOutputSize)\n           If source stream is detected malformed, function returns a negative result.\n\n  Note 1 : @return can be < targetOutputSize, if compressed block contains less data.\n\n  Note 2 : targetOutputSize must be <= dstCapacity\n\n  Note 3 : this function effectively stops decoding on reaching targetOutputSize,\n           so dstCapacity is kind of redundant.\n           This is because in older versions of this function,\n           decoding operation would still write complete sequences.\n           Therefore, there was no guarantee that it would stop writing at exactly targetOutputSize,\n           it could write more bytes, though only up to dstCapacity.\n           Some \"margin\" used to be required for this operation to work properly.\n           Thankfully, this is no longer necessary.\n           The function nonetheless keeps the same signature, in an effort to preserve API compatibility.\n\n  Note 4 : If srcSize is the exact size of the block,\n           then targetOutputSize can be any value,\n           including larger than the block's decompressed size.\n           The function will, at most, generate block's decompressed size.\n\n  Note 5 : If srcSize is _larger_ than block's compressed size,\n           then targetOutputSize **MUST** be <= block's decompressed size.\n           Otherwise, *silent corruption will occur*."]
    pub fn LZ4_decompress_safe_partial(
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        srcSize: ::std::os::raw::c_int,
        targetOutputSize: ::std::os::raw::c_int,
        dstCapacity: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type LZ4_stream_t = LZ4_stream_u;
extern "C" {
    pub fn LZ4_createStream() -> *mut LZ4_stream_t;
}
extern "C" {
    pub fn LZ4_freeStream(streamPtr: *mut LZ4_stream_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_resetStream_fast() : v1.9.0+\n  Use this to prepare an LZ4_stream_t for a new chain of dependent blocks\n  (e.g., LZ4_compress_fast_continue()).\n\n  An LZ4_stream_t must be initialized once before usage.\n  This is automatically done when created by LZ4_createStream().\n  However, should the LZ4_stream_t be simply declared on stack (for example),\n  it's necessary to initialize it first, using LZ4_initStream().\n\n  After init, start any new stream with LZ4_resetStream_fast().\n  A same LZ4_stream_t can be re-used multiple times consecutively\n  and compress multiple streams,\n  provided that it starts each new stream with LZ4_resetStream_fast().\n\n  LZ4_resetStream_fast() is much faster than LZ4_initStream(),\n  but is not compatible with memory regions containing garbage data.\n\n  Note: it's only useful to call LZ4_resetStream_fast()\n        in the context of streaming compression.\n        The *extState* functions perform their own resets.\n        Invoking LZ4_resetStream_fast() before is redundant, and even counterproductive."]
    pub fn LZ4_resetStream_fast(streamPtr: *mut LZ4_stream_t);
}
extern "C" {
    #[doc = " LZ4_loadDict() :\n  Use this function to reference a static dictionary into LZ4_stream_t.\n  The dictionary must remain available during compression.\n  LZ4_loadDict() triggers a reset, so any previous data will be forgotten.\n  The same dictionary will have to be loaded on decompression side for successful decoding.\n  Dictionary are useful for better compression of small data (KB range).\n  While LZ4 accept any input as dictionary,\n  results are generally better when using Zstandard's Dictionary Builder.\n  Loading a size of 0 is allowed, and is the same as reset.\n @return : loaded dictionary size, in bytes (necessarily <= 64 KB)"]
    pub fn LZ4_loadDict(
        streamPtr: *mut LZ4_stream_t,
        dictionary: *const ::std::os::raw::c_char,
        dictSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_compress_fast_continue() :\n  Compress 'src' content using data from previously compressed blocks, for better compression ratio.\n 'dst' buffer must be already allocated.\n  If dstCapacity >= LZ4_compressBound(srcSize), compression is guaranteed to succeed, and runs faster.\n\n @return : size of compressed block\n           or 0 if there is an error (typically, cannot fit into 'dst').\n\n  Note 1 : Each invocation to LZ4_compress_fast_continue() generates a new block.\n           Each block has precise boundaries.\n           Each block must be decompressed separately, calling LZ4_decompress_*() with relevant metadata.\n           It's not possible to append blocks together and expect a single invocation of LZ4_decompress_*() to decompress them together.\n\n  Note 2 : The previous 64KB of source data is __assumed__ to remain present, unmodified, at same address in memory !\n\n  Note 3 : When input is structured as a double-buffer, each buffer can have any size, including < 64 KB.\n           Make sure that buffers are separated, by at least one byte.\n           This construction ensures that each block only depends on previous block.\n\n  Note 4 : If input buffer is a ring-buffer, it can have any size, including < 64 KB.\n\n  Note 5 : After an error, the stream status is undefined (invalid), it can only be reset or freed."]
    pub fn LZ4_compress_fast_continue(
        streamPtr: *mut LZ4_stream_t,
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        srcSize: ::std::os::raw::c_int,
        dstCapacity: ::std::os::raw::c_int,
        acceleration: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_saveDict() :\n  If last 64KB data cannot be guaranteed to remain available at its current memory location,\n  save it into a safer place (char* safeBuffer).\n  This is schematically equivalent to a memcpy() followed by LZ4_loadDict(),\n  but is much faster, because LZ4_saveDict() doesn't need to rebuild tables.\n @return : saved dictionary size in bytes (necessarily <= maxDictSize), or 0 if error."]
    pub fn LZ4_saveDict(
        streamPtr: *mut LZ4_stream_t,
        safeBuffer: *mut ::std::os::raw::c_char,
        maxDictSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type LZ4_streamDecode_t = LZ4_streamDecode_u;
extern "C" {
    pub fn LZ4_createStreamDecode() -> *mut LZ4_streamDecode_t;
}
extern "C" {
    pub fn LZ4_freeStreamDecode(LZ4_stream: *mut LZ4_streamDecode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_setStreamDecode() :\n  An LZ4_streamDecode_t context can be allocated once and re-used multiple times.\n  Use this function to start decompression of a new stream of blocks.\n  A dictionary can optionally be set. Use NULL or size 0 for a reset order.\n  Dictionary is presumed stable : it must remain accessible and unmodified during next decompression.\n @return : 1 if OK, 0 if error"]
    pub fn LZ4_setStreamDecode(
        LZ4_streamDecode: *mut LZ4_streamDecode_t,
        dictionary: *const ::std::os::raw::c_char,
        dictSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_decoderRingBufferSize() : v1.8.2+\n  Note : in a ring buffer scenario (optional),\n  blocks are presumed decompressed next to each other\n  up to the moment there is not enough remaining space for next block (remainingSize < maxBlockSize),\n  at which stage it resumes from beginning of ring buffer.\n  When setting such a ring buffer for streaming decompression,\n  provides the minimum size of this ring buffer\n  to be compatible with any source respecting maxBlockSize condition.\n @return : minimum ring buffer size,\n           or 0 if there is an error (invalid maxBlockSize)."]
    pub fn LZ4_decoderRingBufferSize(maxBlockSize: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_decompress_safe_continue() :\n  This decoding function allows decompression of consecutive blocks in \"streaming\" mode.\n  The difference with the usual independent blocks is that\n  new blocks are allowed to find references into former blocks.\n  A block is an unsplittable entity, and must be presented entirely to the decompression function.\n  LZ4_decompress_safe_continue() only accepts one block at a time.\n  It's modeled after `LZ4_decompress_safe()` and behaves similarly.\n\n @LZ4_streamDecode : decompression state, tracking the position in memory of past data\n @compressedSize : exact complete size of one compressed block.\n @dstCapacity : size of destination buffer (which must be already allocated),\n                must be an upper bound of decompressed size.\n @return : number of bytes decompressed into destination buffer (necessarily <= dstCapacity)\n           If destination buffer is not large enough, decoding will stop and output an error code (negative value).\n           If the source stream is detected malformed, the function will stop decoding and return a negative result.\n\n  The last 64KB of previously decoded data *must* remain available and unmodified\n  at the memory position where they were previously decoded.\n  If less than 64KB of data has been decoded, all the data must be present.\n\n  Special : if decompression side sets a ring buffer, it must respect one of the following conditions :\n  - Decompression buffer size is _at least_ LZ4_decoderRingBufferSize(maxBlockSize).\n    maxBlockSize is the maximum size of any single block. It can have any value > 16 bytes.\n    In which case, encoding and decoding buffers do not need to be synchronized.\n    Actually, data can be produced by any source compliant with LZ4 format specification, and respecting maxBlockSize.\n  - Synchronized mode :\n    Decompression buffer size is _exactly_ the same as compression buffer size,\n    and follows exactly same update rule (block boundaries at same positions),\n    and decoding function is provided with exact decompressed size of each block (exception for last block of the stream),\n    _then_ decoding & encoding ring buffer can have any size, including small ones ( < 64 KB).\n  - Decompression buffer is larger than encoding buffer, by a minimum of maxBlockSize more bytes.\n    In which case, encoding and decoding buffers do not need to be synchronized,\n    and encoding ring buffer can have any size, including small ones ( < 64 KB).\n\n  Whenever these conditions are not possible,\n  save the last 64KB of decoded data into a safe buffer where it can't be modified during decompression,\n  then indicate where this data is saved using LZ4_setStreamDecode(), before decompressing next block."]
    pub fn LZ4_decompress_safe_continue(
        LZ4_streamDecode: *mut LZ4_streamDecode_t,
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        srcSize: ::std::os::raw::c_int,
        dstCapacity: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_decompress_safe_usingDict() :\n  Works the same as\n  a combination of LZ4_setStreamDecode() followed by LZ4_decompress_safe_continue()\n  However, it's stateless: it doesn't need any LZ4_streamDecode_t state.\n  Dictionary is presumed stable : it must remain accessible and unmodified during decompression.\n  Performance tip : Decompression speed can be substantially increased\n                    when dst == dictStart + dictSize."]
    pub fn LZ4_decompress_safe_usingDict(
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        srcSize: ::std::os::raw::c_int,
        dstCapacity: ::std::os::raw::c_int,
        dictStart: *const ::std::os::raw::c_char,
        dictSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_decompress_safe_partial_usingDict() :\n  Behaves the same as LZ4_decompress_safe_partial()\n  with the added ability to specify a memory segment for past data.\n  Performance tip : Decompression speed can be substantially increased\n                    when dst == dictStart + dictSize."]
    pub fn LZ4_decompress_safe_partial_usingDict(
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        compressedSize: ::std::os::raw::c_int,
        targetOutputSize: ::std::os::raw::c_int,
        maxOutputSize: ::std::os::raw::c_int,
        dictStart: *const ::std::os::raw::c_char,
        dictSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type LZ4_i8 = i8;
pub type LZ4_byte = u8;
pub type LZ4_u16 = u16;
pub type LZ4_u32 = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LZ4_stream_t_internal {
    pub hashTable: [LZ4_u32; 4096usize],
    pub dictionary: *const LZ4_byte,
    pub dictCtx: *const LZ4_stream_t_internal,
    pub currentOffset: LZ4_u32,
    pub tableType: LZ4_u32,
    pub dictSize: LZ4_u32,
}
#[test]
fn bindgen_test_layout_LZ4_stream_t_internal() {
    const UNINIT: ::std::mem::MaybeUninit<LZ4_stream_t_internal> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LZ4_stream_t_internal>(),
        16416usize,
        concat!("Size of: ", stringify!(LZ4_stream_t_internal))
    );
    assert_eq!(
        ::std::mem::align_of::<LZ4_stream_t_internal>(),
        8usize,
        concat!("Alignment of ", stringify!(LZ4_stream_t_internal))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hashTable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_stream_t_internal),
            "::",
            stringify!(hashTable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dictionary) as usize - ptr as usize },
        16384usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_stream_t_internal),
            "::",
            stringify!(dictionary)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dictCtx) as usize - ptr as usize },
        16392usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_stream_t_internal),
            "::",
            stringify!(dictCtx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).currentOffset) as usize - ptr as usize },
        16400usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_stream_t_internal),
            "::",
            stringify!(currentOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tableType) as usize - ptr as usize },
        16404usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_stream_t_internal),
            "::",
            stringify!(tableType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dictSize) as usize - ptr as usize },
        16408usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_stream_t_internal),
            "::",
            stringify!(dictSize)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union LZ4_stream_u {
    pub minStateSize: [::std::os::raw::c_char; 16416usize],
    pub internal_donotuse: LZ4_stream_t_internal,
}
#[test]
fn bindgen_test_layout_LZ4_stream_u() {
    const UNINIT: ::std::mem::MaybeUninit<LZ4_stream_u> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LZ4_stream_u>(),
        16416usize,
        concat!("Size of: ", stringify!(LZ4_stream_u))
    );
    assert_eq!(
        ::std::mem::align_of::<LZ4_stream_u>(),
        8usize,
        concat!("Alignment of ", stringify!(LZ4_stream_u))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minStateSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_stream_u),
            "::",
            stringify!(minStateSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_donotuse) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_stream_u),
            "::",
            stringify!(internal_donotuse)
        )
    );
}
extern "C" {
    #[doc = " LZ4_initStream() : v1.9.0+\n  An LZ4_stream_t structure must be initialized at least once.\n  This is automatically done when invoking LZ4_createStream(),\n  but it's not when the structure is simply declared on stack (for example).\n\n  Use LZ4_initStream() to properly initialize a newly declared LZ4_stream_t.\n  It can also initialize any arbitrary buffer of sufficient size,\n  and will @return a pointer of proper type upon initialization.\n\n  Note : initialization fails if size and alignment conditions are not respected.\n         In which case, the function will @return NULL.\n  Note2: An LZ4_stream_t structure guarantees correct alignment and size.\n  Note3: Before v1.9.0, use LZ4_resetStream() instead"]
    pub fn LZ4_initStream(buffer: *mut ::std::os::raw::c_void, size: usize) -> *mut LZ4_stream_t;
}
#[doc = " LZ4_streamDecode_t :\n  Never ever use below internal definitions directly !\n  These definitions are not API/ABI safe, and may change in future versions.\n  If you need static allocation, declare or allocate an LZ4_streamDecode_t object."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LZ4_streamDecode_t_internal {
    pub externalDict: *const LZ4_byte,
    pub prefixEnd: *const LZ4_byte,
    pub extDictSize: usize,
    pub prefixSize: usize,
}
#[test]
fn bindgen_test_layout_LZ4_streamDecode_t_internal() {
    const UNINIT: ::std::mem::MaybeUninit<LZ4_streamDecode_t_internal> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LZ4_streamDecode_t_internal>(),
        32usize,
        concat!("Size of: ", stringify!(LZ4_streamDecode_t_internal))
    );
    assert_eq!(
        ::std::mem::align_of::<LZ4_streamDecode_t_internal>(),
        8usize,
        concat!("Alignment of ", stringify!(LZ4_streamDecode_t_internal))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).externalDict) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_streamDecode_t_internal),
            "::",
            stringify!(externalDict)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prefixEnd) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_streamDecode_t_internal),
            "::",
            stringify!(prefixEnd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extDictSize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_streamDecode_t_internal),
            "::",
            stringify!(extDictSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prefixSize) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_streamDecode_t_internal),
            "::",
            stringify!(prefixSize)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union LZ4_streamDecode_u {
    pub minStateSize: [::std::os::raw::c_char; 32usize],
    pub internal_donotuse: LZ4_streamDecode_t_internal,
}
#[test]
fn bindgen_test_layout_LZ4_streamDecode_u() {
    const UNINIT: ::std::mem::MaybeUninit<LZ4_streamDecode_u> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LZ4_streamDecode_u>(),
        32usize,
        concat!("Size of: ", stringify!(LZ4_streamDecode_u))
    );
    assert_eq!(
        ::std::mem::align_of::<LZ4_streamDecode_u>(),
        8usize,
        concat!("Alignment of ", stringify!(LZ4_streamDecode_u))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minStateSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_streamDecode_u),
            "::",
            stringify!(minStateSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_donotuse) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_streamDecode_u),
            "::",
            stringify!(internal_donotuse)
        )
    );
}
extern "C" {
    #[doc = " Obsolete compression functions (since v1.7.3)"]
    pub fn LZ4_compress(
        src: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        srcSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_compress_limitedOutput(
        src: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        srcSize: ::std::os::raw::c_int,
        maxOutputSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_compress_withState(
        state: *mut ::std::os::raw::c_void,
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        inputSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_compress_limitedOutput_withState(
        state: *mut ::std::os::raw::c_void,
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        inputSize: ::std::os::raw::c_int,
        maxOutputSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_compress_continue(
        LZ4_streamPtr: *mut LZ4_stream_t,
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        inputSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_compress_limitedOutput_continue(
        LZ4_streamPtr: *mut LZ4_stream_t,
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        inputSize: ::std::os::raw::c_int,
        maxOutputSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Obsolete decompression functions (since v1.8.0)"]
    pub fn LZ4_uncompress(
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        outputSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_uncompress_unknownOutputSize(
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        isize_: ::std::os::raw::c_int,
        maxOutputSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_create(inputBuffer: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn LZ4_sizeofStreamState() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_resetStreamState(
        state: *mut ::std::os::raw::c_void,
        inputBuffer: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_slideInputBuffer(state: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Obsolete streaming decoding functions (since v1.7.0)"]
    pub fn LZ4_decompress_safe_withPrefix64k(
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        compressedSize: ::std::os::raw::c_int,
        maxDstSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_decompress_fast_withPrefix64k(
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        originalSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Obsolete LZ4_decompress_fast variants (since v1.9.0) :\n  These functions used to be faster than LZ4_decompress_safe(),\n  but this is no longer the case. They are now slower.\n  This is because LZ4_decompress_fast() doesn't know the input size,\n  and therefore must progress more cautiously into the input buffer to not read beyond the end of block.\n  On top of that `LZ4_decompress_fast()` is not protected vs malformed or malicious inputs, making it a security liability.\n  As a consequence, LZ4_decompress_fast() is strongly discouraged, and deprecated.\n\n  The last remaining LZ4_decompress_fast() specificity is that\n  it can decompress a block without knowing its compressed size.\n  Such functionality can be achieved in a more secure manner\n  by employing LZ4_decompress_safe_partial().\n\n  Parameters:\n  originalSize : is the uncompressed size to regenerate.\n                 `dst` must be already allocated, its size must be >= 'originalSize' bytes.\n @return : number of bytes read from source buffer (== compressed size).\n           The function expects to finish at block's end exactly.\n           If the source stream is detected malformed, the function stops decoding and returns a negative result.\n  note : LZ4_decompress_fast*() requires originalSize. Thanks to this information, it never writes past the output buffer.\n         However, since it doesn't know its 'src' size, it may read an unknown amount of input, past input buffer bounds.\n         Also, since match offsets are not validated, match reads from 'src' may underflow too.\n         These issues never happen if input (compressed) data is correct.\n         But they may happen if input data is invalid (error or intentional tampering).\n         As a consequence, use these functions in trusted environments with trusted data **only**."]
    pub fn LZ4_decompress_fast(
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        originalSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_decompress_fast_continue(
        LZ4_streamDecode: *mut LZ4_streamDecode_t,
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        originalSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_decompress_fast_usingDict(
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        originalSize: ::std::os::raw::c_int,
        dictStart: *const ::std::os::raw::c_char,
        dictSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_resetStream() :\n  An LZ4_stream_t structure must be initialized at least once.\n  This is done with LZ4_initStream(), or LZ4_resetStream().\n  Consider switching to LZ4_initStream(),\n  invoking LZ4_resetStream() will trigger deprecation warnings in the future."]
    pub fn LZ4_resetStream(streamPtr: *mut LZ4_stream_t);
}
extern "C" {
    #[doc = " LZ4_compress_HC() :\n  Compress data from `src` into `dst`, using the powerful but slower \"HC\" algorithm.\n `dst` must be already allocated.\n  Compression is guaranteed to succeed if `dstCapacity >= LZ4_compressBound(srcSize)` (see \"lz4.h\")\n  Max supported `srcSize` value is LZ4_MAX_INPUT_SIZE (see \"lz4.h\")\n `compressionLevel` : any value between 1 and LZ4HC_CLEVEL_MAX will work.\n                      Values > LZ4HC_CLEVEL_MAX behave the same as LZ4HC_CLEVEL_MAX.\n @return : the number of bytes written into 'dst'\n           or 0 if compression fails."]
    pub fn LZ4_compress_HC(
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        srcSize: ::std::os::raw::c_int,
        dstCapacity: ::std::os::raw::c_int,
        compressionLevel: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_compress_HC_extStateHC() :\n  Same as LZ4_compress_HC(), but using an externally allocated memory segment for `state`.\n `state` size is provided by LZ4_sizeofStateHC().\n  Memory segment must be aligned on 8-bytes boundaries (which a normal malloc() should do properly)."]
    pub fn LZ4_sizeofStateHC() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_compress_HC_extStateHC(
        stateHC: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        srcSize: ::std::os::raw::c_int,
        maxDstSize: ::std::os::raw::c_int,
        compressionLevel: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_compress_HC_destSize() : v1.9.0+\n  Will compress as much data as possible from `src`\n  to fit into `targetDstSize` budget.\n  Result is provided in 2 parts :\n @return : the number of bytes written into 'dst' (necessarily <= targetDstSize)\n           or 0 if compression fails.\n `srcSizePtr` : on success, *srcSizePtr is updated to indicate how much bytes were read from `src`"]
    pub fn LZ4_compress_HC_destSize(
        stateHC: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        srcSizePtr: *mut ::std::os::raw::c_int,
        targetDstSize: ::std::os::raw::c_int,
        compressionLevel: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type LZ4_streamHC_t = LZ4_streamHC_u;
extern "C" {
    #[doc = " LZ4_createStreamHC() and LZ4_freeStreamHC() :\n  These functions create and release memory for LZ4 HC streaming state.\n  Newly created states are automatically initialized.\n  A same state can be used multiple times consecutively,\n  starting with LZ4_resetStreamHC_fast() to start a new stream of blocks."]
    pub fn LZ4_createStreamHC() -> *mut LZ4_streamHC_t;
}
extern "C" {
    pub fn LZ4_freeStreamHC(streamHCPtr: *mut LZ4_streamHC_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_resetStreamHC_fast(
        streamHCPtr: *mut LZ4_streamHC_t,
        compressionLevel: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn LZ4_loadDictHC(
        streamHCPtr: *mut LZ4_streamHC_t,
        dictionary: *const ::std::os::raw::c_char,
        dictSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_compress_HC_continue(
        streamHCPtr: *mut LZ4_streamHC_t,
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        srcSize: ::std::os::raw::c_int,
        maxDstSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_compress_HC_continue_destSize() : v1.9.0+\n  Similar to LZ4_compress_HC_continue(),\n  but will read as much data as possible from `src`\n  to fit into `targetDstSize` budget.\n  Result is provided into 2 parts :\n @return : the number of bytes written into 'dst' (necessarily <= targetDstSize)\n           or 0 if compression fails.\n `srcSizePtr` : on success, *srcSizePtr will be updated to indicate how much bytes were read from `src`.\n           Note that this function may not consume the entire input."]
    pub fn LZ4_compress_HC_continue_destSize(
        LZ4_streamHCPtr: *mut LZ4_streamHC_t,
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        srcSizePtr: *mut ::std::os::raw::c_int,
        targetDstSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_saveDictHC(
        streamHCPtr: *mut LZ4_streamHC_t,
        safeBuffer: *mut ::std::os::raw::c_char,
        maxDictSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LZ4HC_CCtx_internal {
    pub hashTable: [LZ4_u32; 32768usize],
    pub chainTable: [LZ4_u16; 65536usize],
    pub end: *const LZ4_byte,
    pub prefixStart: *const LZ4_byte,
    pub dictStart: *const LZ4_byte,
    pub dictLimit: LZ4_u32,
    pub lowLimit: LZ4_u32,
    pub nextToUpdate: LZ4_u32,
    pub compressionLevel: ::std::os::raw::c_short,
    pub favorDecSpeed: LZ4_i8,
    pub dirty: LZ4_i8,
    pub dictCtx: *const LZ4HC_CCtx_internal,
}
#[test]
fn bindgen_test_layout_LZ4HC_CCtx_internal() {
    const UNINIT: ::std::mem::MaybeUninit<LZ4HC_CCtx_internal> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LZ4HC_CCtx_internal>(),
        262192usize,
        concat!("Size of: ", stringify!(LZ4HC_CCtx_internal))
    );
    assert_eq!(
        ::std::mem::align_of::<LZ4HC_CCtx_internal>(),
        8usize,
        concat!("Alignment of ", stringify!(LZ4HC_CCtx_internal))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hashTable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4HC_CCtx_internal),
            "::",
            stringify!(hashTable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chainTable) as usize - ptr as usize },
        131072usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4HC_CCtx_internal),
            "::",
            stringify!(chainTable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end) as usize - ptr as usize },
        262144usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4HC_CCtx_internal),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prefixStart) as usize - ptr as usize },
        262152usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4HC_CCtx_internal),
            "::",
            stringify!(prefixStart)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dictStart) as usize - ptr as usize },
        262160usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4HC_CCtx_internal),
            "::",
            stringify!(dictStart)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dictLimit) as usize - ptr as usize },
        262168usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4HC_CCtx_internal),
            "::",
            stringify!(dictLimit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lowLimit) as usize - ptr as usize },
        262172usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4HC_CCtx_internal),
            "::",
            stringify!(lowLimit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nextToUpdate) as usize - ptr as usize },
        262176usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4HC_CCtx_internal),
            "::",
            stringify!(nextToUpdate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).compressionLevel) as usize - ptr as usize },
        262180usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4HC_CCtx_internal),
            "::",
            stringify!(compressionLevel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).favorDecSpeed) as usize - ptr as usize },
        262182usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4HC_CCtx_internal),
            "::",
            stringify!(favorDecSpeed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dirty) as usize - ptr as usize },
        262183usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4HC_CCtx_internal),
            "::",
            stringify!(dirty)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dictCtx) as usize - ptr as usize },
        262184usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4HC_CCtx_internal),
            "::",
            stringify!(dictCtx)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union LZ4_streamHC_u {
    pub minStateSize: [::std::os::raw::c_char; 262200usize],
    pub internal_donotuse: LZ4HC_CCtx_internal,
}
#[test]
fn bindgen_test_layout_LZ4_streamHC_u() {
    const UNINIT: ::std::mem::MaybeUninit<LZ4_streamHC_u> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LZ4_streamHC_u>(),
        262200usize,
        concat!("Size of: ", stringify!(LZ4_streamHC_u))
    );
    assert_eq!(
        ::std::mem::align_of::<LZ4_streamHC_u>(),
        8usize,
        concat!("Alignment of ", stringify!(LZ4_streamHC_u))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minStateSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_streamHC_u),
            "::",
            stringify!(minStateSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_donotuse) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_streamHC_u),
            "::",
            stringify!(internal_donotuse)
        )
    );
}
extern "C" {
    pub fn LZ4_initStreamHC(
        buffer: *mut ::std::os::raw::c_void,
        size: usize,
    ) -> *mut LZ4_streamHC_t;
}
extern "C" {
    pub fn LZ4_compressHC(
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        inputSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_compressHC_limitedOutput(
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        inputSize: ::std::os::raw::c_int,
        maxOutputSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_compressHC2(
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        inputSize: ::std::os::raw::c_int,
        compressionLevel: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_compressHC2_limitedOutput(
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        inputSize: ::std::os::raw::c_int,
        maxOutputSize: ::std::os::raw::c_int,
        compressionLevel: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_compressHC_withStateHC(
        state: *mut ::std::os::raw::c_void,
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        inputSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_compressHC_limitedOutput_withStateHC(
        state: *mut ::std::os::raw::c_void,
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        inputSize: ::std::os::raw::c_int,
        maxOutputSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_compressHC2_withStateHC(
        state: *mut ::std::os::raw::c_void,
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        inputSize: ::std::os::raw::c_int,
        compressionLevel: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_compressHC2_limitedOutput_withStateHC(
        state: *mut ::std::os::raw::c_void,
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        inputSize: ::std::os::raw::c_int,
        maxOutputSize: ::std::os::raw::c_int,
        compressionLevel: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_compressHC_continue(
        LZ4_streamHCPtr: *mut LZ4_streamHC_t,
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        inputSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_compressHC_limitedOutput_continue(
        LZ4_streamHCPtr: *mut LZ4_streamHC_t,
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        inputSize: ::std::os::raw::c_int,
        maxOutputSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_createHC(inputBuffer: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn LZ4_freeHC(LZ4HC_Data: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_slideInputBufferHC(
        LZ4HC_Data: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn LZ4_compressHC2_continue(
        LZ4HC_Data: *mut ::std::os::raw::c_void,
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        inputSize: ::std::os::raw::c_int,
        compressionLevel: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_compressHC2_limitedOutput_continue(
        LZ4HC_Data: *mut ::std::os::raw::c_void,
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        inputSize: ::std::os::raw::c_int,
        maxOutputSize: ::std::os::raw::c_int,
        compressionLevel: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_sizeofStreamStateHC() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_resetStreamStateHC(
        state: *mut ::std::os::raw::c_void,
        inputBuffer: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_resetStreamHC(
        streamHCPtr: *mut LZ4_streamHC_t,
        compressionLevel: ::std::os::raw::c_int,
    );
}
pub type LZ4F_errorCode_t = usize;
extern "C" {
    pub fn LZ4F_isError(code: LZ4F_errorCode_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn LZ4F_getErrorName(code: LZ4F_errorCode_t) -> *const ::std::os::raw::c_char;
}
pub const LZ4F_blockSizeID_t_LZ4F_default: LZ4F_blockSizeID_t = 0;
pub const LZ4F_blockSizeID_t_LZ4F_max64KB: LZ4F_blockSizeID_t = 4;
pub const LZ4F_blockSizeID_t_LZ4F_max256KB: LZ4F_blockSizeID_t = 5;
pub const LZ4F_blockSizeID_t_LZ4F_max1MB: LZ4F_blockSizeID_t = 6;
pub const LZ4F_blockSizeID_t_LZ4F_max4MB: LZ4F_blockSizeID_t = 7;
pub type LZ4F_blockSizeID_t = ::std::os::raw::c_uint;
pub const LZ4F_blockMode_t_LZ4F_blockLinked: LZ4F_blockMode_t = 0;
pub const LZ4F_blockMode_t_LZ4F_blockIndependent: LZ4F_blockMode_t = 1;
pub type LZ4F_blockMode_t = ::std::os::raw::c_uint;
pub const LZ4F_contentChecksum_t_LZ4F_noContentChecksum: LZ4F_contentChecksum_t = 0;
pub const LZ4F_contentChecksum_t_LZ4F_contentChecksumEnabled: LZ4F_contentChecksum_t = 1;
pub type LZ4F_contentChecksum_t = ::std::os::raw::c_uint;
pub const LZ4F_blockChecksum_t_LZ4F_noBlockChecksum: LZ4F_blockChecksum_t = 0;
pub const LZ4F_blockChecksum_t_LZ4F_blockChecksumEnabled: LZ4F_blockChecksum_t = 1;
pub type LZ4F_blockChecksum_t = ::std::os::raw::c_uint;
pub const LZ4F_frameType_t_LZ4F_frame: LZ4F_frameType_t = 0;
pub const LZ4F_frameType_t_LZ4F_skippableFrame: LZ4F_frameType_t = 1;
pub type LZ4F_frameType_t = ::std::os::raw::c_uint;
#[doc = " LZ4F_frameInfo_t :\n  makes it possible to set or read frame parameters.\n  Structure must be first init to 0, using memset() or LZ4F_INIT_FRAMEINFO,\n  setting all parameters to default.\n  It's then possible to update selectively some parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LZ4F_frameInfo_t {
    pub blockSizeID: LZ4F_blockSizeID_t,
    pub blockMode: LZ4F_blockMode_t,
    pub contentChecksumFlag: LZ4F_contentChecksum_t,
    pub frameType: LZ4F_frameType_t,
    pub contentSize: ::std::os::raw::c_ulonglong,
    pub dictID: ::std::os::raw::c_uint,
    pub blockChecksumFlag: LZ4F_blockChecksum_t,
}
#[test]
fn bindgen_test_layout_LZ4F_frameInfo_t() {
    const UNINIT: ::std::mem::MaybeUninit<LZ4F_frameInfo_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LZ4F_frameInfo_t>(),
        32usize,
        concat!("Size of: ", stringify!(LZ4F_frameInfo_t))
    );
    assert_eq!(
        ::std::mem::align_of::<LZ4F_frameInfo_t>(),
        8usize,
        concat!("Alignment of ", stringify!(LZ4F_frameInfo_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blockSizeID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_frameInfo_t),
            "::",
            stringify!(blockSizeID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blockMode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_frameInfo_t),
            "::",
            stringify!(blockMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).contentChecksumFlag) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_frameInfo_t),
            "::",
            stringify!(contentChecksumFlag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frameType) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_frameInfo_t),
            "::",
            stringify!(frameType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).contentSize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_frameInfo_t),
            "::",
            stringify!(contentSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dictID) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_frameInfo_t),
            "::",
            stringify!(dictID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blockChecksumFlag) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_frameInfo_t),
            "::",
            stringify!(blockChecksumFlag)
        )
    );
}
#[doc = " LZ4F_preferences_t :\n  makes it possible to supply advanced compression instructions to streaming interface.\n  Structure must be first init to 0, using memset() or LZ4F_INIT_PREFERENCES,\n  setting all parameters to default.\n  All reserved fields must be set to zero."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LZ4F_preferences_t {
    pub frameInfo: LZ4F_frameInfo_t,
    pub compressionLevel: ::std::os::raw::c_int,
    pub autoFlush: ::std::os::raw::c_uint,
    pub favorDecSpeed: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_LZ4F_preferences_t() {
    const UNINIT: ::std::mem::MaybeUninit<LZ4F_preferences_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LZ4F_preferences_t>(),
        56usize,
        concat!("Size of: ", stringify!(LZ4F_preferences_t))
    );
    assert_eq!(
        ::std::mem::align_of::<LZ4F_preferences_t>(),
        8usize,
        concat!("Alignment of ", stringify!(LZ4F_preferences_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frameInfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_preferences_t),
            "::",
            stringify!(frameInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).compressionLevel) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_preferences_t),
            "::",
            stringify!(compressionLevel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).autoFlush) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_preferences_t),
            "::",
            stringify!(autoFlush)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).favorDecSpeed) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_preferences_t),
            "::",
            stringify!(favorDecSpeed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_preferences_t),
            "::",
            stringify!(reserved)
        )
    );
}
extern "C" {
    pub fn LZ4F_compressionLevel_max() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4F_compressFrameBound() :\n  Returns the maximum possible compressed size with LZ4F_compressFrame() given srcSize and preferences.\n `preferencesPtr` is optional. It can be replaced by NULL, in which case, the function will assume default preferences.\n  Note : this result is only usable with LZ4F_compressFrame().\n         It may also be relevant to LZ4F_compressUpdate() _only if_ no flush() operation is ever performed."]
    pub fn LZ4F_compressFrameBound(
        srcSize: usize,
        preferencesPtr: *const LZ4F_preferences_t,
    ) -> usize;
}
extern "C" {
    #[doc = " LZ4F_compressFrame() :\n  Compress srcBuffer content into an LZ4-compressed frame.\n  It's a one shot operation, all input content is consumed, and all output is generated.\n\n  Note : it's a stateless operation (no LZ4F_cctx state needed).\n  In order to reduce load on the allocator, LZ4F_compressFrame(), by default,\n  uses the stack to allocate space for the compression state and some table.\n  If this usage of the stack is too much for your application,\n  consider compiling `lz4frame.c` with compile-time macro LZ4F_HEAPMODE set to 1 instead.\n  All state allocations will use the Heap.\n  It also means each invocation of LZ4F_compressFrame() will trigger several internal alloc/free invocations.\n\n @dstCapacity MUST be >= LZ4F_compressFrameBound(srcSize, preferencesPtr).\n @preferencesPtr is optional : one can provide NULL, in which case all preferences are set to default.\n @return : number of bytes written into dstBuffer.\n           or an error code if it fails (can be tested using LZ4F_isError())"]
    pub fn LZ4F_compressFrame(
        dstBuffer: *mut ::std::os::raw::c_void,
        dstCapacity: usize,
        srcBuffer: *const ::std::os::raw::c_void,
        srcSize: usize,
        preferencesPtr: *const LZ4F_preferences_t,
    ) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LZ4F_cctx_s {
    _unused: [u8; 0],
}
pub type LZ4F_cctx = LZ4F_cctx_s;
pub type LZ4F_compressionContext_t = *mut LZ4F_cctx;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LZ4F_compressOptions_t {
    pub stableSrc: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_LZ4F_compressOptions_t() {
    const UNINIT: ::std::mem::MaybeUninit<LZ4F_compressOptions_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LZ4F_compressOptions_t>(),
        16usize,
        concat!("Size of: ", stringify!(LZ4F_compressOptions_t))
    );
    assert_eq!(
        ::std::mem::align_of::<LZ4F_compressOptions_t>(),
        4usize,
        concat!("Alignment of ", stringify!(LZ4F_compressOptions_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stableSrc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_compressOptions_t),
            "::",
            stringify!(stableSrc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_compressOptions_t),
            "::",
            stringify!(reserved)
        )
    );
}
extern "C" {
    pub fn LZ4F_getVersion() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " LZ4F_createCompressionContext() :\n  The first thing to do is to create a compressionContext object,\n  which will keep track of operation state during streaming compression.\n  This is achieved using LZ4F_createCompressionContext(), which takes as argument a version,\n  and a pointer to LZ4F_cctx*, to write the resulting pointer into.\n  @version provided MUST be LZ4F_VERSION. It is intended to track potential version mismatch, notably when using DLL.\n  The function provides a pointer to a fully allocated LZ4F_cctx object.\n  @cctxPtr MUST be != NULL.\n  If @return != zero, context creation failed.\n  A created compression context can be employed multiple times for consecutive streaming operations.\n  Once all streaming compression jobs are completed,\n  the state object can be released using LZ4F_freeCompressionContext().\n  Note1 : LZ4F_freeCompressionContext() is always successful. Its return value can be ignored.\n  Note2 : LZ4F_freeCompressionContext() works fine with NULL input pointers (do nothing)."]
    pub fn LZ4F_createCompressionContext(
        cctxPtr: *mut *mut LZ4F_cctx,
        version: ::std::os::raw::c_uint,
    ) -> LZ4F_errorCode_t;
}
extern "C" {
    pub fn LZ4F_freeCompressionContext(cctx: *mut LZ4F_cctx) -> LZ4F_errorCode_t;
}
extern "C" {
    #[doc = " LZ4F_compressBegin() :\n  will write the frame header into dstBuffer.\n  dstCapacity must be >= LZ4F_HEADER_SIZE_MAX bytes.\n `prefsPtr` is optional : NULL can be provided to set all preferences to default.\n @return : number of bytes written into dstBuffer for the header\n           or an error code (which can be tested using LZ4F_isError())"]
    pub fn LZ4F_compressBegin(
        cctx: *mut LZ4F_cctx,
        dstBuffer: *mut ::std::os::raw::c_void,
        dstCapacity: usize,
        prefsPtr: *const LZ4F_preferences_t,
    ) -> usize;
}
extern "C" {
    #[doc = " LZ4F_compressBound() :\n  Provides minimum dstCapacity required to guarantee success of\n  LZ4F_compressUpdate(), given a srcSize and preferences, for a worst case scenario.\n  When srcSize==0, LZ4F_compressBound() provides an upper bound for LZ4F_flush() and LZ4F_compressEnd() instead.\n  Note that the result is only valid for a single invocation of LZ4F_compressUpdate().\n  When invoking LZ4F_compressUpdate() multiple times,\n  if the output buffer is gradually filled up instead of emptied and re-used from its start,\n  one must check if there is enough remaining capacity before each invocation, using LZ4F_compressBound().\n @return is always the same for a srcSize and prefsPtr.\n  prefsPtr is optional : when NULL is provided, preferences will be set to cover worst case scenario.\n  tech details :\n @return if automatic flushing is not enabled, includes the possibility that internal buffer might already be filled by up to (blockSize-1) bytes.\n  It also includes frame footer (ending + checksum), since it might be generated by LZ4F_compressEnd().\n @return doesn't include frame header, as it was already generated by LZ4F_compressBegin()."]
    pub fn LZ4F_compressBound(srcSize: usize, prefsPtr: *const LZ4F_preferences_t) -> usize;
}
extern "C" {
    #[doc = " LZ4F_compressUpdate() :\n  LZ4F_compressUpdate() can be called repetitively to compress as much data as necessary.\n  Important rule: dstCapacity MUST be large enough to ensure operation success even in worst case situations.\n  This value is provided by LZ4F_compressBound().\n  If this condition is not respected, LZ4F_compress() will fail (result is an errorCode).\n  After an error, the state is left in a UB state, and must be re-initialized or freed.\n  If previously an uncompressed block was written, buffered data is flushed\n  before appending compressed data is continued.\n `cOptPtr` is optional : NULL can be provided, in which case all options are set to default.\n @return : number of bytes written into `dstBuffer` (it can be zero, meaning input data was just buffered).\n           or an error code if it fails (which can be tested using LZ4F_isError())"]
    pub fn LZ4F_compressUpdate(
        cctx: *mut LZ4F_cctx,
        dstBuffer: *mut ::std::os::raw::c_void,
        dstCapacity: usize,
        srcBuffer: *const ::std::os::raw::c_void,
        srcSize: usize,
        cOptPtr: *const LZ4F_compressOptions_t,
    ) -> usize;
}
extern "C" {
    #[doc = " LZ4F_flush() :\n  When data must be generated and sent immediately, without waiting for a block to be completely filled,\n  it's possible to call LZ4_flush(). It will immediately compress any data buffered within cctx.\n `dstCapacity` must be large enough to ensure the operation will be successful.\n `cOptPtr` is optional : it's possible to provide NULL, all options will be set to default.\n @return : nb of bytes written into dstBuffer (can be zero, when there is no data stored within cctx)\n           or an error code if it fails (which can be tested using LZ4F_isError())\n  Note : LZ4F_flush() is guaranteed to be successful when dstCapacity >= LZ4F_compressBound(0, prefsPtr)."]
    pub fn LZ4F_flush(
        cctx: *mut LZ4F_cctx,
        dstBuffer: *mut ::std::os::raw::c_void,
        dstCapacity: usize,
        cOptPtr: *const LZ4F_compressOptions_t,
    ) -> usize;
}
extern "C" {
    #[doc = " LZ4F_compressEnd() :\n  To properly finish an LZ4 frame, invoke LZ4F_compressEnd().\n  It will flush whatever data remained within `cctx` (like LZ4_flush())\n  and properly finalize the frame, with an endMark and a checksum.\n `cOptPtr` is optional : NULL can be provided, in which case all options will be set to default.\n @return : nb of bytes written into dstBuffer, necessarily >= 4 (endMark),\n           or an error code if it fails (which can be tested using LZ4F_isError())\n  Note : LZ4F_compressEnd() is guaranteed to be successful when dstCapacity >= LZ4F_compressBound(0, prefsPtr).\n  A successful call to LZ4F_compressEnd() makes `cctx` available again for another compression task."]
    pub fn LZ4F_compressEnd(
        cctx: *mut LZ4F_cctx,
        dstBuffer: *mut ::std::os::raw::c_void,
        dstCapacity: usize,
        cOptPtr: *const LZ4F_compressOptions_t,
    ) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LZ4F_dctx_s {
    _unused: [u8; 0],
}
pub type LZ4F_dctx = LZ4F_dctx_s;
pub type LZ4F_decompressionContext_t = *mut LZ4F_dctx;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LZ4F_decompressOptions_t {
    pub stableDst: ::std::os::raw::c_uint,
    pub skipChecksums: ::std::os::raw::c_uint,
    pub reserved1: ::std::os::raw::c_uint,
    pub reserved0: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_LZ4F_decompressOptions_t() {
    const UNINIT: ::std::mem::MaybeUninit<LZ4F_decompressOptions_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LZ4F_decompressOptions_t>(),
        16usize,
        concat!("Size of: ", stringify!(LZ4F_decompressOptions_t))
    );
    assert_eq!(
        ::std::mem::align_of::<LZ4F_decompressOptions_t>(),
        4usize,
        concat!("Alignment of ", stringify!(LZ4F_decompressOptions_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stableDst) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_decompressOptions_t),
            "::",
            stringify!(stableDst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).skipChecksums) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_decompressOptions_t),
            "::",
            stringify!(skipChecksums)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_decompressOptions_t),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved0) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_decompressOptions_t),
            "::",
            stringify!(reserved0)
        )
    );
}
extern "C" {
    #[doc = " LZ4F_createDecompressionContext() :\n  Create an LZ4F_dctx object, to track all decompression operations.\n  @version provided MUST be LZ4F_VERSION.\n  @dctxPtr MUST be valid.\n  The function fills @dctxPtr with the value of a pointer to an allocated and initialized LZ4F_dctx object.\n  The @return is an errorCode, which can be tested using LZ4F_isError().\n  dctx memory can be released using LZ4F_freeDecompressionContext();\n  Result of LZ4F_freeDecompressionContext() indicates current state of decompressionContext when being released.\n  That is, it should be == 0 if decompression has been completed fully and correctly."]
    pub fn LZ4F_createDecompressionContext(
        dctxPtr: *mut *mut LZ4F_dctx,
        version: ::std::os::raw::c_uint,
    ) -> LZ4F_errorCode_t;
}
extern "C" {
    pub fn LZ4F_freeDecompressionContext(dctx: *mut LZ4F_dctx) -> LZ4F_errorCode_t;
}
extern "C" {
    #[doc = " LZ4F_headerSize() : v1.9.0+\n  Provide the header size of a frame starting at `src`.\n `srcSize` must be >= LZ4F_MIN_SIZE_TO_KNOW_HEADER_LENGTH,\n  which is enough to decode the header length.\n @return : size of frame header\n           or an error code, which can be tested using LZ4F_isError()\n  note : Frame header size is variable, but is guaranteed to be\n         >= LZ4F_HEADER_SIZE_MIN bytes, and <= LZ4F_HEADER_SIZE_MAX bytes."]
    pub fn LZ4F_headerSize(src: *const ::std::os::raw::c_void, srcSize: usize) -> usize;
}
extern "C" {
    #[doc = " LZ4F_getFrameInfo() :\n  This function extracts frame parameters (max blockSize, dictID, etc.).\n  Its usage is optional: user can also invoke LZ4F_decompress() directly.\n\n  Extracted information will fill an existing LZ4F_frameInfo_t structure.\n  This can be useful for allocation and dictionary identification purposes.\n\n  LZ4F_getFrameInfo() can work in the following situations :\n\n  1) At the beginning of a new frame, before any invocation of LZ4F_decompress().\n     It will decode header from `srcBuffer`,\n     consuming the header and starting the decoding process.\n\n     Input size must be large enough to contain the full frame header.\n     Frame header size can be known beforehand by LZ4F_headerSize().\n     Frame header size is variable, but is guaranteed to be >= LZ4F_HEADER_SIZE_MIN bytes,\n     and not more than <= LZ4F_HEADER_SIZE_MAX bytes.\n     Hence, blindly providing LZ4F_HEADER_SIZE_MAX bytes or more will always work.\n     It's allowed to provide more input data than the header size,\n     LZ4F_getFrameInfo() will only consume the header.\n\n     If input size is not large enough,\n     aka if it's smaller than header size,\n     function will fail and return an error code.\n\n  2) After decoding has been started,\n     it's possible to invoke LZ4F_getFrameInfo() anytime\n     to extract already decoded frame parameters stored within dctx.\n\n     Note that, if decoding has barely started,\n     and not yet read enough information to decode the header,\n     LZ4F_getFrameInfo() will fail.\n\n  The number of bytes consumed from srcBuffer will be updated in *srcSizePtr (necessarily <= original value).\n  LZ4F_getFrameInfo() only consumes bytes when decoding has not yet started,\n  and when decoding the header has been successful.\n  Decompression must then resume from (srcBuffer + *srcSizePtr).\n\n @return : a hint about how many srcSize bytes LZ4F_decompress() expects for next call,\n           or an error code which can be tested using LZ4F_isError().\n  note 1 : in case of error, dctx is not modified. Decoding operation can resume from beginning safely.\n  note 2 : frame parameters are *copied into* an already allocated LZ4F_frameInfo_t structure."]
    pub fn LZ4F_getFrameInfo(
        dctx: *mut LZ4F_dctx,
        frameInfoPtr: *mut LZ4F_frameInfo_t,
        srcBuffer: *const ::std::os::raw::c_void,
        srcSizePtr: *mut usize,
    ) -> usize;
}
extern "C" {
    #[doc = " LZ4F_decompress() :\n  Call this function repetitively to regenerate data compressed in `srcBuffer`.\n\n  The function requires a valid dctx state.\n  It will read up to *srcSizePtr bytes from srcBuffer,\n  and decompress data into dstBuffer, of capacity *dstSizePtr.\n\n  The nb of bytes consumed from srcBuffer will be written into *srcSizePtr (necessarily <= original value).\n  The nb of bytes decompressed into dstBuffer will be written into *dstSizePtr (necessarily <= original value).\n\n  The function does not necessarily read all input bytes, so always check value in *srcSizePtr.\n  Unconsumed source data must be presented again in subsequent invocations.\n\n `dstBuffer` can freely change between each consecutive function invocation.\n `dstBuffer` content will be overwritten.\n\n  Note: if `LZ4F_getFrameInfo()` is called before `LZ4F_decompress()`, srcBuffer must be updated to reflect\n  the number of bytes consumed after reading the frame header. Failure to update srcBuffer before calling\n  `LZ4F_decompress()` will cause decompression failure or, even worse, successful but incorrect decompression.\n  See the `LZ4F_getFrameInfo()` docs for details.\n\n @return : an hint of how many `srcSize` bytes LZ4F_decompress() expects for next call.\n  Schematically, it's the size of the current (or remaining) compressed block + header of next block.\n  Respecting the hint provides some small speed benefit, because it skips intermediate buffers.\n  This is just a hint though, it's always possible to provide any srcSize.\n\n  When a frame is fully decoded, @return will be 0 (no more data expected).\n  When provided with more bytes than necessary to decode a frame,\n  LZ4F_decompress() will stop reading exactly at end of current frame, and @return 0.\n\n  If decompression failed, @return is an error code, which can be tested using LZ4F_isError().\n  After a decompression error, the `dctx` context is not resumable.\n  Use LZ4F_resetDecompressionContext() to return to clean state.\n\n  After a frame is fully decoded, dctx can be used again to decompress another frame."]
    pub fn LZ4F_decompress(
        dctx: *mut LZ4F_dctx,
        dstBuffer: *mut ::std::os::raw::c_void,
        dstSizePtr: *mut usize,
        srcBuffer: *const ::std::os::raw::c_void,
        srcSizePtr: *mut usize,
        dOptPtr: *const LZ4F_decompressOptions_t,
    ) -> usize;
}
extern "C" {
    #[doc = " LZ4F_resetDecompressionContext() : added in v1.8.0\n  In case of an error, the context is left in \"undefined\" state.\n  In which case, it's necessary to reset it, before re-using it.\n  This method can also be used to abruptly stop any unfinished decompression,\n  and start a new one using same context resources."]
    pub fn LZ4F_resetDecompressionContext(dctx: *mut LZ4F_dctx);
}
pub const XXH_errorcode_XXH_OK: XXH_errorcode = 0;
pub const XXH_errorcode_XXH_ERROR: XXH_errorcode = 1;
pub type XXH_errorcode = ::std::os::raw::c_uint;
extern "C" {
    pub fn XXH_versionNumber() -> ::std::os::raw::c_uint;
}
pub type XXH32_hash_t = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " XXH32() :\nCalculate the 32-bit hash of sequence \"length\" bytes stored at memory address \"input\".\nThe memory between input & input+length must be valid (allocated and read-accessible).\n\"seed\" can be used to alter the result predictably.\nSpeed on Core 2 Duo @ 3 GHz (single thread, SMHasher benchmark) : 5.4 GB/s"]
    pub fn XXH32(
        input: *const ::std::os::raw::c_void,
        length: usize,
        seed: ::std::os::raw::c_uint,
    ) -> XXH32_hash_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XXH32_state_s {
    _unused: [u8; 0],
}
pub type XXH32_state_t = XXH32_state_s;
extern "C" {
    pub fn XXH32_createState() -> *mut XXH32_state_t;
}
extern "C" {
    pub fn XXH32_freeState(statePtr: *mut XXH32_state_t) -> XXH_errorcode;
}
extern "C" {
    pub fn XXH32_copyState(dst_state: *mut XXH32_state_t, src_state: *const XXH32_state_t);
}
extern "C" {
    pub fn XXH32_reset(statePtr: *mut XXH32_state_t, seed: ::std::os::raw::c_uint)
        -> XXH_errorcode;
}
extern "C" {
    pub fn XXH32_update(
        statePtr: *mut XXH32_state_t,
        input: *const ::std::os::raw::c_void,
        length: usize,
    ) -> XXH_errorcode;
}
extern "C" {
    pub fn XXH32_digest(statePtr: *const XXH32_state_t) -> XXH32_hash_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XXH32_canonical_t {
    pub digest: [::std::os::raw::c_uchar; 4usize],
}
#[test]
fn bindgen_test_layout_XXH32_canonical_t() {
    const UNINIT: ::std::mem::MaybeUninit<XXH32_canonical_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<XXH32_canonical_t>(),
        4usize,
        concat!("Size of: ", stringify!(XXH32_canonical_t))
    );
    assert_eq!(
        ::std::mem::align_of::<XXH32_canonical_t>(),
        1usize,
        concat!("Alignment of ", stringify!(XXH32_canonical_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).digest) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH32_canonical_t),
            "::",
            stringify!(digest)
        )
    );
}
extern "C" {
    pub fn XXH32_canonicalFromHash(dst: *mut XXH32_canonical_t, hash: XXH32_hash_t);
}
extern "C" {
    pub fn XXH32_hashFromCanonical(src: *const XXH32_canonical_t) -> XXH32_hash_t;
}
pub type XXH64_hash_t = ::std::os::raw::c_ulonglong;
extern "C" {
    #[doc = " XXH64() :\nCalculate the 64-bit hash of sequence of length \"len\" stored at memory address \"input\".\n\"seed\" can be used to alter the result predictably.\nThis function runs faster on 64-bit systems, but slower on 32-bit systems (see benchmark)."]
    pub fn XXH64(
        input: *const ::std::os::raw::c_void,
        length: usize,
        seed: ::std::os::raw::c_ulonglong,
    ) -> XXH64_hash_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XXH64_state_s {
    _unused: [u8; 0],
}
pub type XXH64_state_t = XXH64_state_s;
extern "C" {
    pub fn XXH64_createState() -> *mut XXH64_state_t;
}
extern "C" {
    pub fn XXH64_freeState(statePtr: *mut XXH64_state_t) -> XXH_errorcode;
}
extern "C" {
    pub fn XXH64_copyState(dst_state: *mut XXH64_state_t, src_state: *const XXH64_state_t);
}
extern "C" {
    pub fn XXH64_reset(
        statePtr: *mut XXH64_state_t,
        seed: ::std::os::raw::c_ulonglong,
    ) -> XXH_errorcode;
}
extern "C" {
    pub fn XXH64_update(
        statePtr: *mut XXH64_state_t,
        input: *const ::std::os::raw::c_void,
        length: usize,
    ) -> XXH_errorcode;
}
extern "C" {
    pub fn XXH64_digest(statePtr: *const XXH64_state_t) -> XXH64_hash_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XXH64_canonical_t {
    pub digest: [::std::os::raw::c_uchar; 8usize],
}
#[test]
fn bindgen_test_layout_XXH64_canonical_t() {
    const UNINIT: ::std::mem::MaybeUninit<XXH64_canonical_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<XXH64_canonical_t>(),
        8usize,
        concat!("Size of: ", stringify!(XXH64_canonical_t))
    );
    assert_eq!(
        ::std::mem::align_of::<XXH64_canonical_t>(),
        1usize,
        concat!("Alignment of ", stringify!(XXH64_canonical_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).digest) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH64_canonical_t),
            "::",
            stringify!(digest)
        )
    );
}
extern "C" {
    pub fn XXH64_canonicalFromHash(dst: *mut XXH64_canonical_t, hash: XXH64_hash_t);
}
extern "C" {
    pub fn XXH64_hashFromCanonical(src: *const XXH64_canonical_t) -> XXH64_hash_t;
}
