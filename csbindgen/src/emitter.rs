use std::collections::HashMap;

use crate::builder::BindgenOptions;
use crate::type_meta::*;
use crate::util::*;

pub fn emit_rust_method(list: &Vec<ExternMethod>, options: &BindgenOptions) -> String {
    // configure
    let method_type_path = &options.rust_method_type_path;
    let method_prefix = &options.rust_method_prefix;
    let file_header = &options.rust_file_header;

    let mut methods_string = String::new();

    for item in list {
        let method_name = item.method_name.as_str();
        let parameters = item
            .parameters
            .iter()
            .map(|p| {
                format!(
                    "    {}: {}",
                    p.name,
                    p.rust_type.to_string(method_type_path)
                )
            })
            .collect::<Vec<_>>()
            .join(",\n");

        let return_line = match &item.return_type {
            None => "".to_string(),
            Some(v) => format!(" -> {}", v.to_string(method_type_path)),
        };

        let parameter_only_names = item
            .parameters
            .iter()
            .map(|p| format!("            {}", p.name))
            .collect::<Vec<_>>()
            .join(",\n");

        let template = format!(
            "
#[no_mangle]
pub extern \"C\" fn {method_prefix}{method_name}(
{parameters}    
){return_line}
{{
    unsafe {{
        return {method_type_path}{method_name}(
{parameter_only_names}
        )
    }}
}}
"
        );

        methods_string.push_str(template.as_str());
    }

    let result = format!(
        "// auto-generated via csbindgen

#[allow(unused)]
use ::std::os::raw::*;

{file_header}

{methods_string}
    "
    );

    return result;
}

pub fn emit_csharp(
    methods: &Vec<ExternMethod>,
    aliases: &HashMap<String, RustType>,
    structs: &Vec<RustStruct>,
    options: &BindgenOptions
) -> String {
    // configure
    let namespace = &options.csharp_namespace;
    let class_name = &options.csharp_class_name;
    let dll_name = &options.csharp_dll_name;
    let method_prefix = &options.csharp_method_prefix;

    let mut method_list_string = String::new();
    for item in methods {
        let method_name = &item.method_name;
        let return_type = match &item.return_type {
            Some(x) => x.to_csharp_string(&options, &aliases),
            None => "void".to_string(),
        };

        let parameters = item
            .parameters
            .iter()
            .map(|p| format!("{} {}", p.rust_type.to_csharp_string(&options, &aliases), p.escape_name()))
            .collect::<Vec<_>>()
            .join(", ");

        method_list_string.push_str_ln(
            "        [DllImport(__DllName, CallingConvention = CallingConvention.Cdecl)]",
        );
        method_list_string.push_str_ln(
            format!("        public static extern {return_type} {method_prefix}{method_name}({parameters});").as_str(),
        );
        method_list_string.push_str("\n");
    }

    let mut structs_string = String::new();
    for item in structs {
        let name = &item.struct_name;
        let layout_kind = if item.is_union {
            "Explicit"
        } else {
            "Sequential"
        };

        structs_string
            .push_str_ln(format!("    [StructLayout(LayoutKind.{layout_kind})]").as_str());
        structs_string.push_str_ln(format!("    public unsafe struct {name}").as_str());
        structs_string.push_str_ln("    {");
        for field in &item.fields {
            if item.is_union {
                structs_string.push_str_ln("        [FieldOffset(0)]");
            }
            structs_string.push_str(
                format!(
                    "        public {} {}",
                    field.rust_type.to_csharp_string(&options, &aliases),
                    field.name
                )
                .as_str(),
            );
            if field.rust_type.is_fixed_array {
                let mut digits = field.rust_type.fixed_array_digits.clone();
                if digits == "0" {
                    digits = "1".to_string(); // 0 fixed array is not allowed in C#
                };

                structs_string.push_str(format!("[{}]", digits).as_str());
            }
            structs_string.push_str_ln(";");
        }
        structs_string.push_str_ln("    }");
        structs_string.push_str("\n");
    }

    // TODO: for Unity, `__Intern`.
    let result = format!(
        "// <auto-generated>
// This code is generated via csbindgen.
// DON'T CHANGE THIS DIRECTLY.
// </auto-generated>
using System;
using System.Runtime.InteropServices;

namespace {namespace}
{{
    public static unsafe partial class {class_name}
    {{
        const string __DllName = \"{dll_name}\";

{method_list_string}
    }}

{structs_string}    
}}
    "
    );

    return result;
}
