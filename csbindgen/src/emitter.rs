use crate::alias_map::AliasMap;
use crate::builder::{BindgenOptions, MethodGroup};
use crate::type_meta::ExportSymbolNaming::{ExportName, NoMangle};
use crate::type_meta::*;
use crate::util::*;
use convert_case::{Case, Casing};
use std::collections::HashMap;

pub fn emit_rust_method(list: &Vec<ExternMethod>, options: &BindgenOptions) -> String {
    // configure
    let method_type_path = options.rust_method_type_path.as_str();
    let method_type_path2 = match options.rust_method_type_path.as_str() {
        "" => "".to_string(),
        x => x.to_string() + "::",
    };
    let method_prefix = &options.rust_method_prefix;
    let file_header = &options.rust_file_header;

    let mut methods_string = String::new();

    for item in list {
        let method_name = item.method_name.as_str();
        let parameters = item
            .parameters
            .iter()
            .map(|p| {
                format!(
                    "    {}: {}",
                    p.name,
                    p.rust_type.to_rust_string(method_type_path)
                )
            })
            .collect::<Vec<_>>()
            .join(",\n");

        let return_line = match &item.return_type {
            None => "".to_string(),
            Some(v) => format!(" -> {}", v.to_rust_string(method_type_path)),
        };

        let parameter_only_names = item
            .parameters
            .iter()
            .map(|p| format!("        {}", p.name))
            .collect::<Vec<_>>()
            .join(",\n");

        let template = format!(
            "
#[no_mangle]
pub unsafe extern \"C\" fn {method_prefix}{method_name}(
{parameters}
){return_line}
{{
    {method_type_path2}{method_name}(
{parameter_only_names}
    )
}}
"
        );

        methods_string.push_str(template.as_str());
    }

    let result = format!(
        "/* automatically generated by csbindgen */

#[allow(unused)]
use ::std::os::raw::*;

{file_header}

{methods_string}
    "
    );

    result
}

pub fn emit_csharp(
    methods: &Vec<ExternMethod>,
    aliases: &AliasMap,
    structs: &Vec<RustStruct>,
    enums: &Vec<RustEnum>,
    consts: &Vec<RustConst>,
    options: &BindgenOptions,
) -> String {
    // configure
    let namespace = &options.csharp_namespace;
    let class_name = &options.csharp_class_name;
    let method_prefix = &options.csharp_method_prefix;
    let accessibility = &options.csharp_class_accessibility;

    let mut dll_name = match options.csharp_if_symbol.as_str() {
        "" => format!(
            "        const string __DllName = \"{}\";",
            options.csharp_dll_name
        ),
        _ => {
            format!(
                "#if {0}
        const string __DllName = \"{1}\";
#else
        const string __DllName = \"{2}\";
#endif
        ",
                options.csharp_if_symbol, options.csharp_if_dll_name, options.csharp_dll_name
            )
        }
    };
    if options.csharp_disable_emit_dll_name {
        dll_name = "".to_string();
    }

    let mut method_groups = HashMap::with_capacity(options.csharp_method_groups.len());
    for prefix in &options.csharp_method_groups {
        method_groups.insert(prefix, Vec::new());
    }

    let mut method_list_string = String::new();
    for item in methods {
        if let Some((_, group)) = method_groups
            .iter_mut()
            .find(move |(prefix, _)| item.method_name.starts_with(&prefix.rust_prefix))
        {
            group.push(item);
            continue;
        }

        emit_csharp_native_method(
            aliases,
            options,
            method_prefix,
            accessibility,
            &mut method_list_string,
            &item,
        );
    }

    let structs_string = emit_csharp_structs(aliases, structs, options, accessibility);
    let enum_string = emit_csharp_enums(enums, options, accessibility);
    let const_string = emit_csharp_consts(aliases, consts, options, accessibility);

    // use empty string if the generated class is empty.
    let class_string = if method_list_string.is_empty() && const_string.is_empty() {
        String::new()
    } else {
        format!(
            "    {accessibility} static unsafe partial class {class_name}
    {{
{dll_name}

{const_string}

{method_list_string}
    }}\n"
        )
    };

    let group_classes =
        emit_csharp_method_groups(aliases, options, accessibility, &dll_name, method_groups);

    let file_header = if options.csharp_file_header.len() > 0 {
        options.csharp_file_header.to_string() + "\n"
    } else {
        "".to_string()
    } + "// <auto-generated>
// This code is generated by csbindgen.
// DON'T CHANGE THIS DIRECTLY.
// </auto-generated>
#pragma warning disable CS8500
#pragma warning disable CS8981";
    let file_footer = &options.csharp_file_footer;

    let mut imported_namespaces = String::new();
    for name in &options.csharp_imported_namespaces {
        imported_namespaces.push_str_ln(format!("using {name};").as_str());
    }

    let result = format!(
        "{file_header}
using System;
using System.Runtime.InteropServices;
{imported_namespaces}

namespace {namespace}
{{
{class_string}
{group_classes}
{structs_string}
{enum_string}
}}
{file_footer}"
    );

    result
}

fn emit_csharp_method_groups(
    aliases: &AliasMap,
    options: &BindgenOptions,
    accessibility: &str,
    dll_name: &str,
    method_groups: HashMap<&MethodGroup, Vec<&ExternMethod>>,
) -> String {
    let is_mapped_type = |rust_type: &RustType| -> Option<&str> {
        match &rust_type.type_kind {
            TypeKind::Pointer(_, r) => method_groups.keys().find_map(move |group| {
                if group.rust_type == r.type_name {
                    Some(&*group.csharp_class)
                } else {
                    None
                }
            }),
            _ => None,
        }
    };

    let emit_constructor = |method: &ExternMethod, group: &MethodGroup| -> String {
        match &method.return_type {
            None => panic!("cannot return void from constructor {method:?}"),
            Some(x) => match &x.type_kind {
                TypeKind::Pointer(_, r) => {
                    let actual_type = r.to_csharp_string(
                        options,
                        aliases,
                        false,
                        &method.method_name,
                        &"return".to_string(),
                    );
                    assert_eq!(actual_type, group.rust_type);
                }
                _ => todo!("handle non-pointer return types"),
            },
        };

        let parameters_list = method
            .parameters
            .iter()
            .map(|p| {
                let type_name = match is_mapped_type(&p.rust_type) {
                    None => p.rust_type.to_csharp_string(
                        options,
                        aliases,
                        false,
                        &method.method_name,
                        &p.name,
                    ),
                    Some(csharp_type) => csharp_type.to_string(),
                };
                format!("{} {}", type_name, escape_csharp_name(p.name.as_str()))
            })
            .collect::<Vec<_>>()
            .join(", ");

        let parameters = method
            .parameters
            .iter()
            .map(|p| escape_csharp_name(p.name.as_str()))
            .collect::<Vec<_>>()
            .join(", ");

        let class_name = &group.csharp_class;
        let method_name = &method.method_name;
        format!(
            r#"        {accessibility} {class_name}({parameters_list}) : this({method_name}({parameters})) {{}}"#
        )
    };

    let emit_method = |method: &ExternMethod, group: &MethodGroup| -> String {
        let class_name = &group.csharp_class;
        let csharp_method_name = method.method_name[group.rust_prefix.len()..]
            .to_string()
            .to_case(Case::UpperCamel);

        let first_param_is_instance = method.parameters.first().is_some_and(move |first_param| {
            is_mapped_type(&first_param.rust_type)
                .is_some_and(move |csharp_type| csharp_type == class_name)
        });

        let native_parameters = method
            .parameters
            .iter()
            .enumerate()
            .map(|(index, p)| {
                if index == 0 && first_param_is_instance {
                    "Instance".to_string()
                } else {
                    escape_csharp_name(p.name.as_str())
                        + if is_mapped_type(&p.rust_type).is_some() {
                            ".Instance"
                        } else {
                            ""
                        }
                }
            })
            .collect::<Vec<_>>()
            .join(", ");

        let native_name = &method.method_name;
        let mut native_call = format!("{class_name}.{native_name}({native_parameters})");

        let return_type = match &method.return_type {
            None => {
                native_call.push(';');
                "void".to_string()
            }
            Some(x) => match is_mapped_type(x) {
                Some(mapped_type) => {
                    let is_not_null = if let TypeKind::Pointer(pointer_type, _) = &x.type_kind {
                        matches!(pointer_type, PointerType::NonNull)
                    } else {
                        false
                    };

                    let mut return_type = mapped_type.to_string();
                    native_call = if is_not_null {
                        format!("return new {mapped_type}({native_call});")
                    } else {
                        return_type.push('?');
                        format!(
                            r#"var native = {native_call};
            return native == null ? null : new {mapped_type}(native);"#
                        )
                    };
                    return_type
                }
                None => {
                    native_call = format!("return {native_call};");
                    x.to_csharp_string(
                        options,
                        aliases,
                        false,
                        &method.method_name,
                        &"return".to_string(),
                    )
                }
            },
        };

        let parameter_list = method
            .parameters
            .iter()
            .skip(if first_param_is_instance { 1 } else { 0 })
            .map(|p| {
                let type_name = match is_mapped_type(&p.rust_type) {
                    None => p.rust_type.to_csharp_string(
                        options,
                        aliases,
                        false,
                        &method.method_name,
                        &p.name,
                    ),
                    Some(csharp_type) => csharp_type.to_string(),
                };
                format!("{} {}", type_name, escape_csharp_name(p.name.as_str()))
            })
            .collect::<Vec<_>>()
            .join(", ");

        let modifiers = if first_param_is_instance {
            ""
        } else {
            "static "
        };
        format!(
            r#"        {accessibility} {modifiers}{return_type} {csharp_method_name}({parameter_list})
        {{
            {native_call}
        }}"#
        )
    };

    method_groups
        .iter()
        .filter_map(move |(group, methods)| {
            if methods.is_empty() {
                None
            } else {
                let class_name = &group.csharp_class;
                let rust_prefix = &group.rust_prefix;
                let rust_type = &group.rust_type;

                let mut csharp_methods = String::new();
                let mut native_methods = String::new();
                let constructor_rust_name = format!("{rust_prefix}new");
                let destructor_rust_name = format!("{rust_prefix}free");
                for method in methods {
                    emit_csharp_native_method(
                        aliases,
                        options,
                        &"", // TODO: handle method prefix
                        "private",
                        &mut native_methods,
                        &method,
                    );

                    let method_name = &method.method_name;
                    if *method_name == constructor_rust_name {
                        csharp_methods.push_str_ln(&emit_constructor(method, group));
                        csharp_methods.push('\n');
                        continue;
                    } else if *method_name == destructor_rust_name {
                        continue;
                    }

                    csharp_methods.push_str_ln(&emit_method(method, group));
                    csharp_methods.push('\n');
                }

                let machinery = format!(
                    r#"        private {rust_type}* _instance;
        internal {rust_type}* Instance
        {{
            get
            {{
                if (_instance == null)
                    throw new NullReferenceException("instance is null");
                return _instance;
            }}
        }}

        private {class_name}({rust_type}* instance)
        {{
            ArgumentNullException.ThrowIfNull(instance);
            _instance = instance;
        }}

        internal {rust_type}* Into()
        {{
            var instance = Instance;
            _instance = null;
            return instance;
        }}

        private void Free()
        {{
            if (_instance != null)
                {class_name}.{rust_prefix}free(Into());
        }}

        public void Dispose()
        {{
            Free();
            GC.SuppressFinalize(this);
        }}

        ~{class_name}() => Free();
            "#
                );

                // TODO: use Interlocked.Exchange so this also catches issues with multi threading
                Some(format!(
                    r#"    {accessibility} unsafe sealed partial class {class_name}: IDisposable
    {{
#nullable enable
{csharp_methods}
{machinery}
{dll_name}
#nullable restore
{native_methods}
    }}
"#
                ))
            }
        })
        .collect::<Vec<_>>()
        .join("\n")
}

fn emit_csharp_native_method(
    aliases: &AliasMap,
    options: &BindgenOptions,
    method_prefix: &str,
    accessibility: &str,
    method_list_string: &mut String,
    method: &&ExternMethod,
) {
    let mut method_name = &method.method_name;
    let method_name_temp: String;
    if method_prefix.is_empty() {
        method_name_temp = escape_csharp_name(method_name);
        method_name = &method_name_temp;
    }
    if let Some(x) = &method.return_type {
        if let Some(delegate_method) = build_method_delegate_if_required(
            x,
            options,
            aliases,
            method_name,
            &"return".to_string(),
        ) {
            method_list_string.push_str(
                "        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]\n"
                    .to_string()
                    .as_str(),
            );
            method_list_string
                .push_str(format!("        {accessibility} {delegate_method};\n\n").as_str());
        }
    }

    for p in method.parameters.iter() {
        if let Some(delegate_method) =
            build_method_delegate_if_required(&p.rust_type, options, aliases, method_name, &p.name)
        {
            method_list_string.push_str(
                "        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]\n"
                    .to_string()
                    .as_str(),
            );
            method_list_string
                .push_str(format!("        {accessibility} {delegate_method};\n\n").as_str());
        }
    }

    let entry_point = match &method.export_naming {
        NoMangle => &method.method_name,
        ExportName(export_name) => export_name,
    };

    let entry_point = match options.csharp_entry_point_prefix.as_str() {
        "" => format!("{method_prefix}{entry_point}"),
        x => format!("{x}{entry_point}"),
    };
    let return_type = match &method.return_type {
        Some(x) => x.to_csharp_string(options, aliases, false, method_name, &"return".to_string()),
        None => "void".to_string(),
    };

    let parameters = method
        .parameters
        .iter()
        .map(|p| {
            let mut type_name =
                p.rust_type
                    .to_csharp_string(options, aliases, false, method_name, &p.name);
            if type_name == "bool" {
                type_name = "[MarshalAs(UnmanagedType.U1)] bool".to_string();
            }

            format!("{} {}", type_name, escape_csharp_name(p.name.as_str()))
        })
        .collect::<Vec<_>>()
        .join(", ");

    if let Some(x) = method.escape_doc_comment("        ") {
        method_list_string.push_str_ln(&x);
    }

    method_list_string.push_str_ln(
        format!("        [DllImport(__DllName, EntryPoint = \"{entry_point}\", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]").as_str(),
    );
    if return_type == "bool" {
        method_list_string.push_str_ln("        [return: MarshalAs(UnmanagedType.U1)]");
    }
    method_list_string.push_str_ln(
        format!("        {accessibility} static extern {return_type} {method_prefix}{method_name}({parameters});").as_str(),
    );
    method_list_string.push('\n');
}

fn emit_csharp_enums(
    enums: &Vec<RustEnum>,
    options: &BindgenOptions,
    accessibility: &String,
) -> String {
    let mut enum_string = String::new();
    for item in enums {
        let repr = match &item.repr {
            Some(x) => format!(" : {}", convert_token_enum_repr(x)),
            None => "".to_string(),
        };
        let name = (options.csharp_type_rename)(escape_csharp_name(&item.enum_name));
        if item.is_flags {
            enum_string.push_str_ln("    [Flags]");
        }
        enum_string.push_str_ln(format!("    {accessibility} enum {name}{repr}").as_str());
        enum_string.push_str_ln("    {");
        for (name, value) in &item.fields {
            let value = match value {
                Some(x) => format!(" = {x},"),
                None => ",".to_string(),
            };
            enum_string.push_str_ln(format!("        {name}{value}").as_str());
        }
        enum_string.push_str_ln("    }");
        enum_string.push('\n');
    }
    enum_string
}

fn emit_csharp_structs(
    aliases: &AliasMap,
    structs: &Vec<RustStruct>,
    options: &BindgenOptions,
    accessibility: &String,
) -> String {
    let mut structs_string = String::new();
    for item in structs {
        let name = (options.csharp_type_rename)(escape_csharp_name(&item.struct_name));
        let layout_kind = if item.is_union {
            "Explicit"
        } else {
            "Sequential"
        };

        structs_string
            .push_str_ln(format!("    [StructLayout(LayoutKind.{layout_kind})]").as_str());
        structs_string
            .push_str_ln(format!("    {accessibility} unsafe partial struct {name}").as_str());
        structs_string.push_str_ln("    {");
        for field in &item.fields {
            if item.is_union {
                structs_string.push_str_ln("        [FieldOffset(0)]");
            }

            let type_name = field.rust_type.to_csharp_string(
                options,
                aliases,
                true,
                &"".to_string(),
                &"".to_string(),
            );
            let attr = if type_name == "bool" {
                "[MarshalAs(UnmanagedType.U1)] ".to_string()
            } else {
                "".to_string()
            };

            structs_string.push_str(
                format!(
                    "        {}public {} {}",
                    attr,
                    type_name,
                    escape_csharp_name(field.name.as_str())
                )
                .as_str(),
            );

            if let TypeKind::FixedArray(digits, _) = &field.rust_type.type_kind {
                let mut digits = digits.clone();
                if digits == "0" {
                    digits = "1".to_string(); // 0 fixed array is not allowed in C#
                };

                structs_string.push_str(format!("[{}]", digits).as_str());
            } else {
                let alias_resolved_field =
                    match aliases.get_mapped_value(&field.rust_type.type_name) {
                        Some(x) => x,
                        None => field.rust_type.clone(),
                    };

                if let TypeKind::FixedArray(digits, _) = &alias_resolved_field.type_kind {
                    let mut digits = digits.clone();
                    if digits == "0" {
                        digits = "1".to_string(); // 0 fixed array is not allowed in C#
                    };

                    structs_string.push_str(format!("[{}]", digits).as_str());
                }
            }

            structs_string.push_str_ln(";");
        }
        structs_string.push_str_ln("    }");
        structs_string.push('\n');
    }
    structs_string
}

fn emit_csharp_consts(
    aliases: &AliasMap,
    consts: &Vec<RustConst>,
    options: &BindgenOptions,
    accessibility: &String,
) -> String {
    let mut const_string: String = String::new();
    for item in consts {
        let mut type_name = item.rust_type.to_csharp_string(
            options,
            aliases,
            false,
            &"".to_string(),
            &"".to_string(),
        );

        // special case for string, char, ByteStr
        if item.value.starts_with("\"") {
            type_name = "string".to_string();
        } else if item.value.starts_with("\'") {
            type_name = "char".to_string();
        }

        if item.value.starts_with("[") {
            const_string.push_str(
                format!(
                    "        {} static ReadOnlySpan<byte> {} => new byte[] {};\n",
                    accessibility,
                    escape_csharp_name(item.const_name.as_str()),
                    item.value.replace("[", "{ ").replace("]", " }")
                )
                .as_str(),
            );
        } else {
            let value = if type_name == "float" {
                format!("{}f", item.value)
            } else {
                item.value.to_string()
            };

            const_string.push_str(
                format!(
                    "        {} const {} {} = {};\n",
                    accessibility,
                    type_name,
                    escape_csharp_name(item.const_name.as_str()),
                    value
                )
                .as_str(),
            );
        }
    }
    const_string
}

fn convert_token_enum_repr(repr: &str) -> &str {
    match repr {
        "(C)" => "uint",
        "(u8)" => "byte",
        "(u16)" => "ushort",
        "(u32)" => "uint",
        "(u64)" => "ulong",
        "(i8)" => "sbyte",
        "(i16)" => "short",
        "(i32)" => "int",
        "(i64)" => "long",
        "C" => "uint",
        "u8" => "byte",
        "u16" => "ushort",
        "u32" => "uint",
        "u64" => "ulong",
        "i8" => "sbyte",
        "i16" => "short",
        "i32" => "int",
        "i64" => "long",
        x => x,
    }
}
